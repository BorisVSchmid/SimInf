## SimInf, a framework for stochastic disease spread simulations
## Copyright (C) 2015  Pavol Bauer
## Copyright (C) 2015 - 2017  Stefan Engblom
## Copyright (C) 2015 - 2017  Stefan Widgren
##
## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

##' Class \code{"SimInf_model"}
##'
##' Class to handle the siminf data model
##' @section Slots:
##' \describe{
##'   \item{G}{
##'     Dependency graph that indicates the transition rates that need
##'     to be updated after a given state transition has occured.
##'     A non-zero entry in element \code{G[i, i]} indicates that transition
##'     rate \code{i} needs to be recalculated if the state transition
##'     \code{j} occurs. Sparse matrix (\eqn{Nt \times Nt}) of object class
##'     \code{"\linkS4class{dgCMatrix}"}.
##'   }
##'   \item{S}{
##'     Each column corresponds to a state transition, and execution
##'     of state transition \code{j} amounts to adding the \code{S[,
##'     j]} column to the state vector \code{u[, i]} of node \emph{i}
##'     where the transition occurred. Sparse matrix (\eqn{Nc \times
##'     Nt}) of object class \code{"\linkS4class{dgCMatrix}"}.
##'   }
##'   \item{U}{
##'     The result matrix with the number of individuals in each
##'     compartment in every node. \code{U[, j]} contains the number
##'     of individuals in each compartment at
##'     \code{tspan[j]}. \code{U[1:Nc, j]} contains the number of
##'     individuals in node 1 at \code{tspan[j]}. \code{U[(Nc + 1):(2
##'     * Nc), j]} contains the number of individuals in node 2 at
##'     \code{tspan[j]} etc. Integer matrix (\eqn{N_n N_c \times}
##'     \code{length(tspan)}).
##'   }
##'   \item{U_sparse}{
##'     If the model was run to write the solution to a sparse matrix
##'     (\code{dgCMatrix}) the \code{U_sparse} contains the data and
##'     \code{U} is empty. The layout of the data in \code{U_sparse}
##'     is identical to \code{U}. Please note that \code{U_sparse}
##'     is numeric and \code{U} is integer.
##'   }
##'   \item{V}{
##'     The result matrix for the real-valued continuous
##'     state. \code{V[, j]} contains the real-valued state of the
##'     system at \code{tspan[j]}. Numeric matrix
##'     (\eqn{N_n}\code{dim(ldata)[1]} \eqn{\times}
##'     \code{length(tspan)}).
##'   }
##'   \item{V_sparse}{
##'     If the model was run to write the solution to a sparse matrix
##'     (\code{dgCMatrix}) the \code{V_sparse} contains the data and
##'     \code{V} is empty. The layout of the data in \code{V_sparse}
##'     is identical to \code{V}.
##'   }
##'   \item{ldata}{
##'     A matrix with local data for the nodes. The column \code{ldata[, j]}
##'     contains the local data vector for the node \code{j}. The local
##'     data vector is passed as an argument to the transition rate
##'     functions and the post time step function.
##'   }
##'   \item{gdata}{
##'     A numeric vector with global data that is common to all nodes.
##'     The global data vector is passed as an argument to the
##'     transition rate functions and the post time step function.
##'   }
##'   \item{tspan}{
##'     A vector of increasing time points where the state of each node is
##'     to be returned.
##'   }
##'   \item{u0}{
##'     The initial state vector (\eqn{N_c \times N_n}) with
##'     the number of individuals in each compartment in every node.
##'   }
##'   \item{v0}{
##'      The initial value for the real-valued continuous state.
##'      Numeric matrix (\code{dim(ldata)[1]} \eqn{\times N_n}).
##'   }
##'   \item{events}{
##'     Scheduled events \code{"\linkS4class{SimInf_events}"}
##'   }
##'   \item{C_code}{
##'     Character vector with optional model C code. If non-empty, the
##'     C code is written to a temporary C-file when the \code{run}
##'     method is called.  The temporary C-file is compiled and the
##'     resulting DLL is dynamically loaded. The DLL is unloaded and
##'     the temporary files are removed after running the model.
##'   }
##' }
##' @include SimInf_events.R
##' @export
##' @importClassesFrom Matrix dgCMatrix
setClass("SimInf_model",
         slots = c(G        = "dgCMatrix",
                   S        = "dgCMatrix",
                   U        = "matrix",
                   U_sparse = "dgCMatrix",
                   ldata    = "matrix",
                   gdata    = "numeric",
                   tspan    = "numeric",
                   u0       = "matrix",
                   V        = "matrix",
                   V_sparse = "dgCMatrix",
                   v0       = "matrix",
                   events   = "SimInf_events",
                   C_code   = "character"),
         validity = function(object) {
             ## Check events
             errors <- methods::validObject(object@events)
             if (identical(errors, TRUE))
                 errors <- character()

             ## Check tspan.
             if (!is.double(object@tspan)) {
                 errors <- c(errors, "Input time-span must be a double vector.")
             } else if (any(length(object@tspan) < 2,
                            any(diff(object@tspan) <= 0),
                            any(is.na(object@tspan)))) {
                 errors <- c(errors,
                             "Input time-span must be an increasing vector.")
             }

             ## Check u0.
             if (!identical(storage.mode(object@u0), "integer")) {
                 errors <- c(errors,
                             "Initial state 'u0' must be an integer matrix.")
             } else if (any(object@u0 < 0L)) {
                 errors <- c(errors,
                             "Initial state 'u0' has negative elements.")
             }

             ## Check U.
             if (!identical(storage.mode(object@U), "integer")) {
                 errors <- c(errors,
                             "Output state 'U' must be an integer matrix.")
             } else if (any(object@U < 0L)) {
                 errors <- c(errors,
                             "Output state 'U' has negative elements.")
             }

             ## Check v0.
             if (!identical(storage.mode(object@v0), "double")) {
                 errors <- c(errors,
                             "Initial model state 'v0' must be a double matrix.")
             }

             ## Check V.
             if (!identical(storage.mode(object@V), "double")) {
                 errors <- c(errors,
                             "Output model state 'V' must be a double matrix.")
             }

             ## Check S.
             if (!all(is_wholenumber(object@S@x))) {
                 errors <- c(errors,
                             "'S' matrix must be an integer matrix.")
             }

             ## Check G.
             Nt <- dim(object@S)[2]
             if (!identical(dim(object@G), c(Nt, Nt))) {
                 errors <- c(errors,
                             "Wrong size of dependency graph.")
             }

             ## Check ldata.
             if (!is.double(object@ldata)) {
                 errors <- c(errors,
                             "'ldata' matrix must be a double matrix.")
             }
             Nn <- dim(object@u0)[2]
             if (!identical(dim(object@ldata)[2], Nn)) {
                 errors <- c(errors,
                             "Wrong size of 'ldata' matrix.")
             }

             ## Check gdata.
             if (!is.double(object@gdata)) {
                 errors <- c(errors,
                             "'gdata' must be a double vector.")
             }

             if (length(errors) == 0) TRUE else errors
         }
)

##' Create a \code{SimInf_model}
##'
##' @param G Dependency graph that indicates the transition rates that
##'     need to be updated after a given state transition has occured.
##'     A non-zero entry in element \code{G[i, i]} indicates that
##'     transition rate \code{i} needs to be recalculated if the state
##'     transition \code{j} occurs. Sparse matrix (\eqn{Nt \times Nt})
##'     of object class \code{"\linkS4class{dgCMatrix}"}.
##' @param S Each column corresponds to a transition, and execution of
##'     state transition \code{j} amounts to adding the \code{S[, j]}
##'     to the state vector of the node where the state transition
##'     occurred.  Sparse matrix (\eqn{Nc \times Nt}) of object class
##'     \code{"\linkS4class{dgCMatrix}"}.
##' @param U The result matrix with the number of individuals in each
##'     disease state in every node (\eqn{N_n N_c \times}
##'     \code{length(tspan)}).  \code{U[, j]} contains the number of
##'     individuals in each disease state at
##'     \code{tspan[j]}. \code{U[1:Nc, j]} contains the state of node
##'     \code{1} at \code{tspan[j]}. \code{U[(Nc + 1):(2 * Nc), j]}
##'     contains the state of node \code{2} at \code{tspan[j]} etc.
##' @param ldata A matrix with local data for the nodes. The column
##'     \code{ldata[, j]} contains the local data vector for the node
##'     \code{j}. The local data vector is passed as an argument to
##'     the transition rate functions and the post time step function.
##' @param gdata A numeric vector with global data that is common to
##'     all nodes. The global data vector is passed as an argument to
##'     the transition rate functions and the post time step function.
##' @template tspan-param
##' @param u0 The initial state vector. Either a matrix (\eqn{N_c
##'     \times N_n}) or a a \code{data.frame} with the number of
##'     individuals in each compartment in every node.
##' @param events A \code{data.frame} with the scheduled events.
##' @param V The result matrix for the real-valued continous
##'     compartment state (\eqn{N_n}\code{dim(ldata)[1]} \eqn{\times}
##'     \code{length(tspan)}).  \code{V[, j]} contains the real-valued
##'     state of the system at \code{tspan[j]}.
##' @param v0 The initial continuous state vector in every node.
##'     (\code{dim(ldata)[1]} \eqn{N_N \times}). The continuous state
##'     vector is updated by the specific model during the simulation
##'     in the post time step function.
##' @param E Sparse matrix to handle scheduled events, see
##'     \code{\linkS4class{SimInf_events}}.
##' @param N Sparse matrix to handle scheduled events, see
##'     \code{\linkS4class{SimInf_events}}.
##' @param C_code Character vector with optional model C code. If
##'     non-empty, the C code is written to a temporary C-file when
##'     the \code{run} method is called.  The temporary C-file is
##'     compiled and the resulting DLL is dynamically loaded. The DLL
##'     is unloaded and the temporary files are removed after running
##'     the model.
##' @return \linkS4class{SimInf_model}
##' @export
SimInf_model <- function(G,
                         S,
                         tspan,
                         events = NULL,
                         ldata  = NULL,
                         gdata  = NULL,
                         U      = NULL,
                         u0     = NULL,
                         v0     = NULL,
                         V      = NULL,
                         E      = NULL,
                         N      = NULL,
                         C_code = NULL)
{
    ## Check u0
    if (is.null(u0))
        stop("'u0' is NULL")
    if (is.data.frame(u0)) {
        n_col <- ncol(u0)
        n_row <- nrow(u0)
        lbl <- colnames(u0)
        u0 <- t(data.matrix(u0))
        attributes(u0) <- NULL
        dim(u0) <- c(n_col, n_row)
        rownames(u0) <- lbl
    }
    if (!all(is.matrix(u0), is.numeric(u0)))
        stop("u0 must be an integer matrix")
    if (!is.integer(u0)) {
        if (!all(is_wholenumber(u0)))
            stop("u0 must be an integer matrix")
        storage.mode(u0) <- "integer"
    }

    ## Check G
    if (class(G) == "dsCMatrix")
        G <- methods::as(G, "dgCMatrix")

    ## Check ldata
    if (is.null(ldata))
        ldata <- matrix(rep(0, ncol(u0)), nrow = 1)

    ## Check gdata
    if (is.null(gdata))
        gdata <- numeric(0)

    ## Check U
    if (is.null(U)) {
        U <- matrix(nrow = 0, ncol = 0)
        storage.mode(U) <- "integer"
    } else {
        if (!is.integer(U)) {
            if (!all(is_wholenumber(U)))
                stop("U must be an integer")
            storage.mode(U) <- "integer"
        }

        if (!is.matrix(U)) {
            if (!identical(length(U), 0L))
                stop("U must be equal to 0 x 0 matrix")
            dim(U) <- c(0, 0)
        }
    }

    ## Check v0
    if (is.null(v0)) {
        v0 <- matrix(nrow = 0, ncol = 0)
        storage.mode(v0) <- "double"
    } else {
        if (!all(is.matrix(v0), is.numeric(v0)))
            stop("v0 must be a numeric matrix")

        if (!identical(storage.mode(v0), "double"))
            storage.mode(v0) <- "double"
    }

    ## Check V
    if (is.null(V)) {
        V <- matrix(nrow = 0, ncol = 0)
        storage.mode(V) <- "double"
    } else {
        if (!is.numeric(V))
            stop("V must be numeric")

        if (!identical(storage.mode(V), "double"))
            storage.mode(V) <- "double"

        if (!is.matrix(V)) {
            if (!identical(length(V), 0L))
                stop("V must be equal to 0 x 0 matrix")
            dim(V) <- c(0, 0)
        }
    }

    ## Check tspan
    if (methods::is(tspan, "Date")) {
        ## Coerce the date vector to a numeric vector as days, where
        ## tspan[1] becomes the day of the year of the first year of
        ## the tspan date vector. The dates are added as names to the
        ## numeric vector.
        t0 <- as.numeric(as.Date(format(tspan[1], "%Y-01-01"))) - 1
        tspan_lbl <- format(tspan, "%Y-%m-%d")
        tspan <- as.numeric(tspan) - t0
        names(tspan) <- tspan_lbl
    } else {
        t0 <- NULL
    }
    storage.mode(tspan) <- "double"

    ## Check events
    if (!any(is.null(events), is.data.frame(events)))
        stop("'events' must be NULL or a data.frame")
    events <- SimInf_events(E = E, N = N, events = events, t0 = t0)

    ## Check C code
    if (is.null(C_code))
        C_code <- character(0)

    return(methods::new("SimInf_model",
                        G      = G,
                        S      = S,
                        U      = U,
                        ldata  = ldata,
                        gdata  = gdata,
                        tspan  = tspan,
                        u0     = u0,
                        v0     = v0,
                        V      = V,
                        events = events,
                        C_code = C_code))
}

##' Calculate the prevalence of disease found in a trajectory
##'
##' Calculate the proportion of individuals with disease, or the
##' proportion of nodes with individuals with disease, or the
##' proportion of individuals with disease in each node.
##' @param model The \code{model} to calculate the prevalence from.
##' @param cases The compartments in the population with a disease or
##'     a condition.
##' @param pop The compartments that define the entire population of
##'     interest.
##' @param type The type of prevalence measure to calculate:
##'     \code{'pop'} (default) calcalates the proportion of the
##'     individuals in the population that have disease (model
##'     specific) at each time point in \code{tspan}, \code{'nop'}
##'     calculates the node prevalence, and \code{'wnp'} calculates
##'     the within-node prevalence.
##' @param i Indices specifying the nodes to include in the
##'     calculation of the prevalence. Default is \code{NULL}, which
##'     includes all nodes.
##' @param as.is The default (\code{as.is = FALSE}) is to generate a
##'     \code{data.frame} with one row per time-step with the
##'     prevalence. Using \code{as.is = TRUE} returns the result as a
##'     matrix, which is the internal format.
##' @return Vector when type equals \code{'pop'} or \code{'nop'} but
##'     matrix when type equals \code{'wnp'}.
##' @export
prevalence <- function(model = NULL,
                       cases = NULL,
                       pop = NULL,
                       type = c("pop", "nop", "wnp"),
                       i = NULL,
                       as.is = FALSE)
{
    ## Check model argument
    if (is.null(model))
        stop("Missing 'model' argument")
    if (!is(model, "SimInf_model"))
        stop("'model' argument is not a 'SimInf_model'")

    ## Check 'cases' argument
    cases <- as.character(cases)
    if (!length(cases))
        stop("'cases' is empty")
    j <- !(cases %in% rownames(model@S))
    if (any(j)) {
        stop("Non-existing compartment(s) in model: ",
             paste0("'", cases[j], "'", collapse = ", "))
    }

    ## Check 'pop' argument
    pop <- as.character(pop)
    if (!length(pop))
        stop("'pop' is empty")
    j <- !(pop %in% rownames(model@S))
    if (any(j)) {
        stop("Non-existing compartment(s) in model: ",
             paste0("'", pop[j], "'", collapse = ", "))
    }

    ## Check 'i' argument
    if (!is.null(i)) {
        if (!is.numeric(i))
            stop("'i' must be integer")
        if (!all(is_wholenumber(i)))
            stop("'i' must be integer")
        if (min(i) < 1)
            stop("'i' must be integer > 0")
        if (max(i) > Nn(model))
            stop("'i' must be integer <= number of nodes")
    }

    ## Check 'type' argument
    type <- match.arg(type)

    ## Sum all individuals in 'cases' compartments in a matrix with
    ## one row per node X length(tspan)
    cm <- NULL
    for (compartment in cases) {
        if (is.null(cm)) {
            cm <- trajectory(model, compartments = compartment, i = i, as.is = TRUE)
        } else {
            cm <- cm + trajectory(model, compartments = compartment, i = i, as.is = TRUE)
        }
    }
    dimnames(cm) <- NULL

    ## Sum all individuals in 'pop' compartments in a matrix with one
    ## row per node X length(tspan)
    pm <- NULL
    for (compartment in pop) {
        if (is.null(pm)) {
            pm <- trajectory(model, compartments = compartment, i = i, as.is = TRUE)
        } else {
            pm <- pm + trajectory(model, compartments = compartment, i = i, as.is = TRUE)
        }
    }
    dimnames(pm) <- NULL

    if (identical(type, "pop")) {
        cm <- colSums(cm)
        pm <- colSums(pm)
    } else if (identical(type, "nop")) {
        cm <- colSums(cm > 0)
        ## Only include nodes with individuals
        pm <- colSums(pm > 0)
    }

    if (isTRUE(as.is))
        return(cm / pm)

    Time <- names(model@tspan)
    if (is.null(Time))
        Time <- model@tspan
    if (type %in% c("pop", "nop"))
        return(data.frame(Time = Time, Prevalence = cm / pm))

    Node = seq_len(Nn(model))
    if (!is.null(i))
        Node <- Node[i]

    data.frame(Node = Node,
               Time = rep(Time, each = length(Node)),
               Prevalence = as.numeric(cm / pm),
               stringsAsFactors = FALSE)
}

##' Coerce a sparse matrix to a data.frame
##'
##' Utility function to coerce a sparse matrix (U_sparse or V_sparse)
##' to a data.frame.
##' @param m sparse matrix to coerce.
##' @param n number of rows per node.
##' @param tspan time points in trajectory.
##' @param lbl labels for data e.g. compartments.
##' @param value default value.
##' @return \code{data.frame}
##' @noRd
sparse2df <- function(m, n, tspan, lbl, value = NA_integer_) {
    ## Determine nodes and time-points with output.
    Node <- as.integer(ceiling((m@i + 1) / n))
    Time <- names(tspan)
    if (is.null(Time))
        Time <- as.integer(tspan)
    Time <- cbind(Time, diff(m@p))
    Time <- unlist(apply(Time, 1, function(x) rep(x[1], x[2])))

    ## Determine unique combinations of Node and Time
    i <- !duplicated(cbind(Node, Time))
    Node <- Node[i]
    Time <- Time[i]

    ## Use Node and Time to determine the required size
    ## of a matrix to hold all output data and fill it
    ## with NA values.
    values <- matrix(value, nrow = sum(i), ncol = n)
    colnames(values) <- lbl

    ## And then update non-NA items with values from m.
    i <- cumsum(i)
    j <- m@i %% n + 1
    if (is.integer(value)) {
        values[matrix(c(i, j), ncol = 2)] <- as.integer(m@x)
    } else {
        values[matrix(c(i, j), ncol = 2)] <- m@x
    }

    cbind(Node = Node,
          Time = Time,
          as.data.frame(values),
          stringsAsFactors = FALSE)
}

##' Extract data from a simulated trajectory
##'
##' Extract the number of individuals in each compartment the number
##' of individuals in each compartment in every node after running a
##' trajectory with \code{\link{run}}.
##'
##' Description of the layout of the matrix that is returned if
##' \code{as.is = TRUE}. \code{U[, j]} contains the number of
##' individuals in each compartment at \code{tspan[j]}. \code{U[1:Nc,
##' j]} contains the number of individuals in node 1 at
##' \code{tspan[j]}. \code{U[(Nc + 1):(2 * Nc), j]} contains the
##' number of individuals in node 2 at \code{tspan[j]} etc, where
##' \code{Nc} is the number of compartments in the model. The
##' dimension of the matrix is \eqn{N_n N_c \times}
##' \code{length(tspan)} where \eqn{N_n} is the number of nodes.
##' @param model the \code{model} to extract the result from.
##' @param compartments specify the compartments to extract the number
##'     of individuals from. Default (\code{compartments=NULL}) is to
##'     extract data from all compartments in the model.
##' @param i indices specifying the nodes to include when extracting
##'     data. Default is \code{NULL}, which includes all nodes.
##' @param as.is the default (\code{as.is = FALSE}) is to generate a
##'     \code{data.frame} with one row per node and time-step with the
##'     number of individuals in each compartment. Using \code{as.is =
##'     TRUE} returns the result as a matrix, which is the internal
##'     format (see \sQuote{Details}).
##' @return The number of individuals in each compartment
##' @export
##' @importFrom methods is
##' @examples
##' ## Create an 'SIR' model with 6 nodes and initialize
##' ## it to run over 10 days.
##' u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
##' model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
##'
##' ## Run the model
##' result <- run(model, threads = 1, seed = 22)
##'
##' ## Extract the number of individuals in each compartment at the
##' ## time-points in tspan.
##' trajectory(result)
##'
##' ## Extract the number of recovered individuals in the first node
##' ## after each time step in the simulation.
##' trajectory(result, compartments = "R", i = 1)
##'
##' ## Extract the number of recovered individuals in the first and
##' ## third node after each time step in the simulation.
##' trajectory(result, compartments = "R", i = c(1, 3))
##'
##' ## Create an 'SISe' model with 6 nodes and initialize
##' ## it to run over 10 days.
##' u0 <- data.frame(S = 100:105, I = 1:6)
##' model <- SISe(u0 = u0, tspan = 1:10, phi = rep(0, 6),
##'     upsilon = 0.02, gamma = 0.1, alpha = 1, epsilon = 1.1e-5,
##'     beta_t1 = 0.15, beta_t2 = 0.15, beta_t3 = 0.15, beta_t4 = 0.15,
##'     end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365)
##'
##' ## Run the model
##' result <- run(model, threads = 1, seed = 7)
##'
##' ## Extract the continuous state variable 'V1' in each node at the
##' ## time-points in tspan. In the 'SISe' model, 'V1' represents the
##' ## environmental infectious pressure 'phi'.
##' trajectory(result, "V1")
trajectory <- function(model, compartments = NULL, i = NULL, as.is = FALSE)
{
    ## Check that the arguments are ok...

    ## Check model argument
    if (missing(model))
        stop("Missing 'model' argument")
    if (!is(model, "SimInf_model"))
        stop("'model' argument is not a 'SimInf_model'")

    if (all(identical(dim(model@U), c(0L, 0L)),
            identical(dim(model@U_sparse), c(0L, 0L)),
            identical(dim(model@V), c(0L, 0L)),
            identical(dim(model@V_sparse), c(0L, 0L)))) {
        stop("Please run the model first, the trajectory is empty")
    }

    ## Split the 'compartments' argument to match the compartments in
    ## U and V.
    compartments_U <- NULL
    compartments_V <- NULL
    if (!is.null(compartments)) {
        compartments <- unique(as.character(compartments))

        ## Match compartments in U
        lbl <- rownames(model@S)
        compartments_U <- compartments[compartments %in% lbl]
        if (length(compartments_U) > 0) {
            compartments <- setdiff(compartments, compartments_U)
        } else {
            compartments_U <- NULL
        }

        ## Match compartments in V
        if (length(compartments) > 0) {
            if (Nd(model) > 0) {
                lbl <- paste0("V", seq_len(Nd(model)))
                compartments_V <- compartments[compartments %in% lbl]
                if (length(compartments_V) > 0) {
                    compartments <- setdiff(compartments, compartments_V)
                } else {
                    compartments_V <- NULL
                }
            }
        }

        if (length(compartments) > 0) {
            stop("Non-existing compartment(s) in model: ",
                 paste0("'", compartments, "'", collapse = ", "))
        }

        ## Cannot combine data from U and V when as.is = TRUE or when
        ## both U and V are sparse.
        if (all(!is.null(compartments_U), !is.null(compartments_V))) {
            if (isTRUE(as.is))
                stop("Select either continuous or discrete compartments")
            if (all(!identical(dim(model@U_sparse), c(0L, 0L)),
                    !identical(dim(model@V_sparse), c(0L, 0L))))
                stop("Select either continuous or discrete compartments")
        }
    }

    ## Check the 'i' argument
    if (!is.null(i)) {
        if (!is.numeric(i))
            stop("'i' must be integer")
        if (!all(is_wholenumber(i)))
            stop("'i' must be integer")
        if (min(i) < 1)
            stop("'i' must be integer > 0")
        if (max(i) > Nn(model))
            stop("'i' must be integer <= number of nodes")
        i <- sort(i)
    }

    ## The arguments seem ok...go on and extract the trajectory

    ## Check to extract sparse data from V
    if (!identical(dim(model@V_sparse), c(0L, 0L))) {
        if (!is.null(compartments_V)) {
            if (isTRUE(as.is))
                return(model@V_sparse)

            ## Coerce the sparse 'V_sparse' matrix to a data.frame with
            ## one row per node and time-point with the values of the
            ## continuous state variables.
            return(sparse2df(model@V_sparse, Nd(model), model@tspan,
                             paste0("V", seq_len(Nd(model))), NA_real_))
        }
    }

    ## Check to extract sparse data from U
    if (!identical(dim(model@U_sparse), c(0L, 0L))) {
        if (isTRUE(as.is))
            return(model@U_sparse)

        ## Coerce the sparse 'U_sparse' matrix to a data.frame with
        ## one row per node and time-point with the number of
        ## individuals in each compartment.
        return(sparse2df(model@U_sparse, Nc(model),
                         model@tspan, rownames(model@S)))
    }

    ## Check to extract data in internal matrix format
    if (isTRUE(as.is)) {
        if (is.null(i)) {
            if (is.null(compartments_U)) {
                if (is.null(compartments_V))
                    return(model@U)
                if (identical(length(compartments_V), Nd(model)))
                    return(model@V)
            } else if (identical(length(compartments_U), Nc(model))) {
                return(model@U)
            }
        }

        if (is.null(i))
            i <- seq_len(Nn(model))

        if (all(is.null(compartments_U), is.null(compartments_V)))
            compartments_U <- rownames(model@S)

        if (is.null(compartments_U)) {
            ## Extract subset of data from V
            lbl <- paste0("V", seq_len(Nd(model)))
            compartments_V <- sort(match(compartments_V, lbl))
            j <- rep(compartments_V, length(i))
            j <- j + rep((i - 1) * Nd(model), each = length(compartments_V))
            return(model@V[j, , drop = FALSE])
        }

        ## Extract subset of data from U
        compartments_U <- sort(match(compartments_U, rownames(model@S)))
        j <- rep(compartments_U, length(i))
        j <- j + rep((i - 1) * Nc(model), each = length(compartments_U))
        return(model@U[j, , drop = FALSE])
    }

    ## Coerce the dense 'U' and 'V' matrices to a data.frame with one
    ## row per node and time-point with data from the specified
    ## discrete and continuous states.
    mU <- NULL
    mV <- NULL

    ## Handle first cases where all data in U and/or V are extracted,
    ## where 'all' indicates that all compartments in U or V are
    ## specified.
    ##
    ## compartments_U compartments_V output
    ##     NULL           NULL         U
    ##     NULL            all         V
    ##      all           NULL         U
    ##      all            all        U+V
    if (is.null(i)) {
        if (is.null(compartments_U)) {
            if (is.null(compartments_V)) {
                mU <- matrix(as.integer(model@U), ncol = Nc(model), byrow = TRUE)
            } else if (identical(length(compartments_V), Nd(model))) {
                mV <- matrix(as.numeric(model@V), ncol = Nd(model), byrow = TRUE)
            }
        } else if (identical(length(compartments_U), Nc(model))) {
            if (is.null(compartments_V)) {
                mU <- matrix(as.integer(model@U), ncol = Nc(model), byrow = TRUE)
            } else if (identical(length(compartments_V), Nd(model))) {
                mU <- matrix(as.integer(model@U), ncol = Nc(model), byrow = TRUE)
                mV <- matrix(as.numeric(model@V), ncol = Nd(model), byrow = TRUE)
            }
        }

        if (!is.null(mU))
            colnames(mU) <- rownames(model@S)
        if (!is.null(mV))
            colnames(mV) <- paste0("V", seq_len(Nd(model)))
    }

    ## Handle cases where a subset of data in U and/or V are
    ## extracted.
    if (all(is.null(mU), is.null(mV))) {
        if (is.null(i))
            i <- seq_len(Nn(model))

        if (all(is.null(compartments_U), is.null(compartments_V)))
            compartments_U <- rownames(model@S)

        if (!is.null(compartments_U)) {
            ## Extract a subset of data from U
            compartments_U <- sort(match(compartments_U, rownames(model@S)))
            j <- rep(compartments_U, length(i))
            j <- j + rep((i - 1) * Nc(model), each = length(compartments_U))
            k <- (seq_len(length(model@tspan)) - 1) * Nc(model) * Nn(model)
            k <- rep(k, each = length(j))
            j <- rep(j, length(model@tspan))
            j <- j + k
            mU <- matrix(as.integer(model@U[j]),
                         ncol = length(compartments_U),
                         byrow = TRUE)
            colnames(mU) <- rownames(model@S)[compartments_U]
        }

        if (!is.null(compartments_V)) {
            ## Extract a subset of data from V
            compartments_V <- sort(match(compartments_V, paste0("V", seq_len(Nd(model)))))
            j <- rep(compartments_V, length(i))
            j <- j + rep((i - 1) * Nd(model), each = length(compartments_V))
            k <- (seq_len(length(model@tspan)) - 1) * Nd(model) * Nn(model)
            k <- rep(k, each = length(j))
            j <- rep(j, length(model@tspan))
            j <- j + k
            mV <- matrix(as.numeric(model@V[j]),
                         ncol = length(compartments_V),
                         byrow = TRUE)
            colnames(mV) <- paste0("V", seq_len(Nd(model)))[compartments_V]
        }
    }

    Node = seq_len(Nn(model))
    if (!is.null(i))
        Node <- Node[i]

    Time <- names(model@tspan)
    if (is.null(Time))
        Time <- as.integer(model@tspan)
    Time <- rep(Time, each = length(Node))

    result <- data.frame(Node = Node, Time = Time, stringsAsFactors = FALSE)
    if (!is.null(mU))
        result <- cbind(result, as.data.frame(mU))

    if (!is.null(mV))
        result <- cbind(result, as.data.frame(mV))

    result
}

##' Set a template for where to write the U result matrix
##'
##' @param model The \code{model} to set a template for the result
##'     matrix \code{U}.
##' @param value Write the number of individuals in each compartment
##'     at \code{tspan} to the non-zero elements in \code{value},
##'     where \code{value} is a sparse matrix, \code{dgCMatrix}, with
##'     dimension \eqn{N_n N_c \times} \code{length(tspan)}. Default
##'     is \code{NULL} i.e. to write the number of inidividuals in
##'     each compartment in every node to a dense matrix.
##' @export
##' @importFrom methods is
##' @examples
##' ## Create an 'SIR' model with 6 nodes and initialize
##' ## it to run over 10 days.
##' u0 <- data.frame(S = 100:105, I = 1:6, R = rep(0, 6))
##' model <- SIR(u0 = u0, tspan = 1:10, beta = 0.16, gamma = 0.077)
##'
##' ## An example with a sparse U result matrix, which can save a lot
##' ## of memory if the model contains many nodes and time-points, but
##' ## where only a few of the data points are of interest. First
##' ## create a sparse matrix with non-zero entries at the locations
##' ## in U where the number of individuals should be written. Then
##' ## run the model with the sparse matrix as a template for U where
##' ## to write data.
##' m <- Matrix::sparseMatrix(1:18, rep(5:10, each = 3))
##' U(model) <- m
##' result <- run(model, threads = 1, seed = 22)
##'
##' ## Extract the number of individuals in each compartment at the
##' ## time-points in tspan.
##' trajectory(result)
"U<-" <- function(model, value)
{
    ## Check model argument
    if (missing(model))
        stop("Missing 'model' argument")
    if (!is(model, "SimInf_model"))
        stop("'model' argument is not a 'SimInf_model'")

    if (!is.null(value)) {
        if (!methods::is(value, "dgCMatrix"))
            value <- methods::as(value, "dgCMatrix")

        d <- c(Nn(model) * Nc(model), length(model@tspan))
        if (!identical(dim(value), d))
            stop("Wrong dimension of 'value'")

        ## Clear dense result matrix
        u <- matrix(nrow = 0, ncol = 0)
        storage.mode(u) <- "integer"
        model@U = u

        model@U_sparse = value
    } else {
        ## Clear sparse result matrix
        model@U_sparse <- methods::as(Matrix::sparseMatrix(numeric(0),
                                                           numeric(0),
                                                           dims = c(0, 0)),
                                      "dgCMatrix")
    }
    model
}

##' Set a template for where to write the V result matrix
##'
##' @param model The \code{model} to set a template for the result
##'     matrix \code{V}.
##' @param value Write the real-valued continuous state at
##'     \code{tspan} to the non-zero elements in \code{value}, where
##'     \code{value} is a sparse matrix, \code{dgCMatrix}, with
##'     dimension \eqn{N_n}\code{dim(ldata)[1]} \eqn{\times}
##'     \code{length(tspan)}. Default is \code{NULL} i.e. to write the
##'     real-valued continuous state to a dense matrix.
##' @export
##' @importFrom methods is
##' @importFrom methods as
##' @importFrom Matrix sparseMatrix
##' @examples
##' ## Create an 'SISe' model with 6 nodes and initialize
##' ## it to run over 10 days.
##' u0 <- data.frame(S = 100:105, I = 1:6)
##' model <- SISe(u0 = u0, tspan = 1:10, phi = rep(0, 6),
##'     upsilon = 0.02, gamma = 0.1, alpha = 1, epsilon = 1.1e-5,
##'     beta_t1 = 0.15, beta_t2 = 0.15, beta_t3 = 0.15, beta_t4 = 0.15,
##'     end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365)
##'
##' ## An example with a sparse V result matrix, which can save a lot
##' ## of memory if the model contains many nodes and time-points, but
##' ## where only a few of the data points are of interest. First
##' ## create a sparse matrix with non-zero entries at the locations
##' ## in V where the continuous state variables should be written. Then
##' ## run the model with the sparse matrix as a template for V where
##' ## to write data.
##' m <- Matrix::sparseMatrix(1:6, 5:10)
##' V(model) <- m
##' result <- run(model, threads = 1, seed = 7)
##'
##' ## Extract the continuous state variable 'V1' at the time-points in tspan.
##' trajectory(result, compartments = "V1")
"V<-" <- function(model, value)
{
    if (!is.null(value)) {
        if (!is(value, "dgCMatrix"))
            value <- as(value, "dgCMatrix")

        d <- c(Nn(model) * Nd(model), length(model@tspan))
        if (!identical(dim(value), d))
            stop("Wrong dimension of 'value'")

        ## Clear dense result matrix
        v <- matrix(nrow = 0, ncol = 0)
        storage.mode(v) <- "double"
        model@V <- v

        model@V_sparse = value
    } else {
        ## Clear sparse result matrix
        model@V_sparse <- as(sparseMatrix(numeric(0),
                                          numeric(0),
                                          dims = c(0, 0)),
                             "dgCMatrix")
    }
    model
}

## Number of nodes
Nn <- function(model) {
    dim(model@u0)[2]
}

## Number of compartments
Nc <- function(model) {
    dim(model@S)[1]
}

## Number of transitions
Nt <- function(model) {
    dim(model@G)[1]
}

## Number of continuous state variables
Nd <- function(model) {
    dim(model@v0)[1]
}

##' Run the SimInf stochastic simulation algorithm
##'
##' @param model The siminf model to run.
##' @param threads Number of threads. Default is NULL, i.e. to use all
##'     available processors.
##' @param seed Random number seed. Default is NULL, i.e. the
##'     simulator uses time to seed the random number generator.
##' @param solver Which numerical solver to utilize. Default is Null, i.e.
##'     SSA is the default solver.
##' @return \code{SimInf_model} with result from simulation.
##' @examples
##' ## Create an 'SIR' model with 10 nodes and initialise
##' ## it to run over 100 days.
##' model <- SIR(u0 = data.frame(S = rep(99, 10),
##'                              I = rep(1, 10),
##'                              R = rep(0, 10)),
##'              tspan = 1:100,
##'              beta = 0.16,
##'              gamma = 0.077)
##'
##' ## Run the model and save the result.
##' result <- run(model, threads = 1, seed = 1)
##'
##' ## Plot the proportion of susceptible, infected and recovered
##' ## individuals.
##' plot(result)
setGeneric("run",
           signature = "model",
           function(model,
                    threads = NULL,
                    seed    = NULL,
                    solver  = NULL)
               standardGeneric("run"))

##' @rdname run
##' @export
setMethod("run",
          signature(model = "SimInf_model"),
          function(model, threads, seed, solver)
          {
              ## Check that SimInf_model contains all data structures
              ## required by the siminf solver and that they make sense
              methods::validObject(model);

              if (nchar(paste0(model@C_code, collapse = "\n"))) {
                  ## Write the C code to a temporary file
                  filename <- tempfile("SimInf-")
                  on.exit(unlink(paste0(filename,
                                        c(".c", ".o", .Platform$dynlib.ex))))
                  writeLines(model@C_code, con = paste0(filename, ".c"))

                  ## Include directive for "SimInf.h"
                  include <- system.file("include", package = "SimInf")
                  Sys.setenv(PKG_CPPFLAGS=sprintf("-I%s", shQuote(include)))

                  ## Compile the model C code using the running version of R.
                  wd <- setwd(dirname(filename))
                  cmd <- paste(shQuote(file.path(R.home(component="bin"), "R")),
                               "CMD SHLIB",
                               shQuote(paste0(basename(filename), ".c")))
                  compiled <- system(cmd, intern = TRUE)
                  setwd(wd)

                  ## Load DLL
                  lib <- paste0(filename, .Platform$dynlib.ext)
                  if (!file.exists(lib))
                      stop(compiled)
                  dll <- dyn.load(lib)
                  on.exit(dyn.unload(lib), add = TRUE)

                  ## Create expression to parse
                  expr <- ".Call(dll$SimInf_model_run, model, threads, seed, solver)"
              } else {
                  ## The model name
                  name <- as.character(class(model))

                  ## The model C run function
                  run_fn <- paste0(name, "_run")

                  ## Create expression to parse
                  expr <- ".Call(run_fn, model, threads, seed, solver, PACKAGE = 'SimInf')"
              }

              ## Run model
              eval(parse(text = expr))
          }
)

##' Box plot of number of individuals in each compartment
##'
##' Produce box-and-whisker plot(s) of the number of individuals in
##' each model compartment.
##' @param x The \code{model} to plot
##' @param ... Additional arguments affecting the plot produced.
##' @aliases boxplot,SimInf_model-method
##' @export
##' @examples
##' ## Create an 'SIR' model with 10 nodes and initialise
##' ## it with 99 susceptible individuals and one infected
##' ## individual. Let the model run over 100 days.
##' model <- SIR(u0 = data.frame(S = rep(99, 10),
##'                              I = rep(1, 10),
##'                              R = rep(0, 10)),
##'              tspan = 1:100,
##'              beta = 0.16,
##'              gamma = 0.077)
##'
##' ## Run the model and save the result.
##' result <- run(model, threads = 1, seed = 1)
##'
##' ## Create a boxplot
##' boxplot(result)
setMethod("boxplot",
          signature(x = "SimInf_model"),
          function(x, ...)
          {
              graphics::boxplot(trajectory(x)[-(1:2)], ...)
          }
)

##' Scatterplot of number of individuals in each compartment
##'
##' A matrix of scatterplots with the number of individuals in each
##' compartment is produced. The \code{ij}th scatterplot contains
##' \code{x[,i]} plotted against \code{x[,j]}.
##' @param x The \code{model} to plot
##' @param ... Additional arguments affecting the plot produced.
##' @export
##' @examples
##' ## Create an 'SIR' model with 10 nodes and initialise
##' ## it with 99 susceptible individuals and one infected
##' ## individual. Let the model run over 100 days.
##' model <- SIR(u0 = data.frame(S = rep(99, 10),
##'                              I = rep(1, 10),
##'                              R = rep(0, 10)),
##'              tspan = 1:100,
##'              beta = 0.16,
##'              gamma = 0.077)
##'
##' ## Run the model and save the result.
##' result <- run(model, threads = 1, seed = 1)
##'
##' ## Create a scatter plot
##' pairs(result)
setMethod("pairs",
          signature(x = "SimInf_model"),
          function(x, ...)
          {
              graphics::pairs(trajectory(x)[-(1:2)], ...)
          }
)

##' Display the outcome from a simulated trajectory
##'
##' @param x The \code{model} to plot
##' @param legend The character vector to appear in the
##'     legend. Default is to use the names of the compartments.
##' @param col The plotting color for each compartment. Default is
##'     black.
##' @param lty The line type for each compartment. Default is the
##'     sequence: 1=solid, 2=dashed, 3=dotted, 4=dotdash, 5=longdash,
##'     6=twodash.
##' @param lwd The line width for each compartment. Default is 2.
##' @param N if \code{TRUE}, the average number of individuals in each
##'     compartment, else the proportion of individuals in each
##'     compartment.  Default is \code{FALSE}.
##' @param compartments Character vector with the compartments in the
##'     model to include in the plot. Default is \code{NULL}
##'     i.e. include all compartments in the model.
##' @param spaghetti Plot one line for each node. Default is
##'     \code{FALSE}.
##' @param ... Additional arguments affecting the plot produced.
##' @rdname plot
##' @aliases plot,SimInf_model-method
##' @export
##' @examples
##' ## Create an 'SIR' model with 10 nodes and initialise
##' ## it with 99 susceptible individuals and one infected
##' ## individual. Let the model run over 100 days.
##' model <- SIR(u0 = data.frame(S = rep(99, 10),
##'                              I = rep(1, 10),
##'                              R = rep(0, 10)),
##'              tspan = 1:100,
##'              beta = 0.16,
##'              gamma = 0.077)
##'
##' ## Run the model and save the result.
##' result <- run(model, threads = 1, seed = 1)
##'
##' ## Plot the proportion of susceptible, infected and recovered
##' ## individuals.
##' plot(result)
##'
##' ## Plot the number of susceptible, infected and recovered
##' ## individuals.
##' plot(result, N = TRUE)
##'
##' ## Plot the number of infected individuals.
##' plot(result, compartments = "I", N = TRUE)
setMethod("plot",
          signature(x = "SimInf_model"),
          function(x, legend = NULL, col = NULL, lty = NULL, lwd = 2,
                   N = FALSE, compartments = NULL, spaghetti = FALSE,
                   ...)
          {
              if (identical(dim(x@U), c(0L, 0L)))
                  stop("Please run the model first, the 'U' matrix is empty")

              ## Determine the compartments to include in the plot
              if (is.null(compartments)) {
                  compartments <- seq_len(Nc(x))
              } else {
                  if (!(all(compartments %in% rownames(x@S))))
                      stop("'compartments' must exist in the model")
                  compartments <- match(compartments, rownames(x@S))
              }

              savepar <- graphics::par(mar = c(2,4,1,1), oma = c(4,1,0,0),
                                       xpd = TRUE)
              on.exit(graphics::par(savepar))

              ## Create a matrix with one row for each line in the
              ## plot.
              if (identical(spaghetti, TRUE)) {
                  i <- sort(as.numeric(sapply(compartments, "+",
                  (seq_len(Nn(x)) - 1) * Nc(x))))
                  m <- x@U[i, , drop = FALSE]

                  if (!identical(N, TRUE)) {
                      ## Calculate the proportion of individuals in
                      ## each compartment within each node.
                      for (i in (seq_len(Nn(x)) - 1)) {
                          n <- colSums(x@U[i * Nc(x) + seq_len(Nc(x)), ,
                                           drop = FALSE])
                          j <- i * length(compartments) +
                              seq_len(length(compartments))
                          m[j, ] <- m[j, , drop = FALSE] / n
                      }
                  }
              } else {
                  m <- matrix(0, nrow = length(compartments),
                              ncol = length(x@tspan))
                  for (i in seq_len(length(compartments))) {
                      j <- seq(from = compartments[i], to = dim(x@U)[1],
                               by = Nc(x))
                      if (N) {
                          m[i, ] <- colMeans(as.matrix(x@U[j, , drop = FALSE]))
                      } else {
                          m[i, ] <- colSums(as.matrix(x@U[j, , drop = FALSE]))
                      }
                  }

                  ## Calculate proportion
                  if (!identical(N, TRUE))
                      m <- apply(m, 2, function(x) x / sum(x))
              }

              ## Default line type
              if (is.null(lty)) {
                  if (is.null(col)) {
                      lty <- seq_len(length(compartments))
                  } else {
                      lty <- rep(1, length(compartments))
                  }
              }
              lty <- rep(lty, length.out = dim(m)[1])

              ## Default color is black
              if (is.null(col)) {
                  col <- rep("black", length(compartments))
              } else {
                  col <- col[compartments]
              }
              col <- rep(col, length.out = dim(m)[1])

              ## Settings for the y-axis.
              if (identical(N, TRUE)) {
                  ylab <- "N"
                  ylim <- c(0, max(m))
              } else {
                  ylab <- "Proportion"
                  ylim <- c(0, 1)
              }

              ## Settings for the x-axis
              if (is.null(names(x@tspan))) {
                  xx <- x@tspan
                  xlab <- "Time"
              } else {
                  xx <- as.Date(names(x@tspan))
                  xlab <- "Date"
              }

              ## Plot first line to get a new plot window
              graphics::plot(x = xx, y = m[1, ], type = "l",
                             ylab = ylab, ylim = ylim, col = col[1],
                             lty = lty[1], lwd = lwd, ...)
              graphics::title(xlab = xlab, outer = TRUE, line = 0)

              ## Add the rest of the lines to the plot
              for (i in seq_len(dim(m)[1])[-1]) {
                  graphics::lines(x = xx, y = m[i, ], type = "l",
                                  lty = lty[i], col = col[i], lwd = lwd,
                                  ...)
              }

              ## Add the legend below plot. The default legend is the
              ## names of the compartments.
              if (is.null(legend))
                  legend <- rownames(x@S)[compartments]
              graphics::par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0),
                            mar = c(0, 0, 0, 0), new = TRUE)
              graphics::plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
              graphics::legend("bottom", inset = c(0, 0),
                               lty = lty[seq_len(length(compartments))],
                               col = col[seq_len(length(compartments))],
                               bty = "n", horiz = TRUE,
                               legend = legend, lwd = lwd)
          }
)

##' @noRd
show_U <- function(object) {
    d <- dim(object@U)
    if (identical(d, c(0L, 0L))) {
        d <- dim(object@U_sparse)
        if (identical(d, c(0L, 0L))) {
            cat("U: 0 x 0\n")
        } else {
            cat(sprintf("U: %i x %i (sparse)\n", d[1], d[2]))
        }
    } else {
        cat(sprintf("U: %i x %i\n", d[1], d[2]))
    }
}

##' @noRd
show_V <- function(object) {
    d <- dim(object@V)
    if (identical(d, c(0L, 0L))) {
        d <- dim(object@V_sparse)
        if (identical(d, c(0L, 0L))) {
            cat("V: 0 x 0\n")
        } else {
            cat(sprintf("V: %i x %i (sparse)\n", d[1], d[2]))
        }
    } else {
        cat(sprintf("V: %i x %i\n", d[1], d[2]))
    }
}

summary_U <- function(object)
{
    cat("Discrete state variables (U):\n")
    d <- dim(object@U)
    if (identical(d, c(0L, 0L)))
        d <- dim(object@U_sparse)
    if (identical(d, c(0L, 0L))) {
        cat(" - Empty, please run the model first\n")
    } else {
        qq <- lapply(rownames(object@S), function(compartment) {
            x <- as.numeric(trajectory(object, compartment, as.is = TRUE))
            qq <- stats::quantile(x)
            qq <- c(qq[1L:3L], mean(x), qq[4L:5L])
        })
        qq <- do.call("rbind", qq)
        colnames(qq) <- c("Min.", "1st Qu.", "Median",
                          "Mean", "3rd Qu.", "Max.")
        rownames(qq) <- paste0(" ", rownames(object@S))
        print.table(qq, digits = 3)
    }
}

summary_V <- function(object)
{
    cat("Continuous state variables (V):\n")
    if (Nd(object) > 0) {
        d <- dim(object@V)
        if (identical(d, c(0L, 0L)))
            d <- dim(object@V_sparse)
        if (identical(d, c(0L, 0L))) {
            cat(" - Empty, please run the model first\n")
        } else {
            qq <- lapply(seq_len(Nd(object)), function(compartment) {
                compartment <- paste0("V", compartment)
                x <- as.numeric(trajectory(object, compartment, as.is = TRUE))
                qq <- stats::quantile(x)
                qq <- c(qq[1L:3L], mean(x), qq[4L:5L])
            })
            qq <- do.call("rbind", qq)
            colnames(qq) <- c("Min.", "1st Qu.", "Median",
                              "Mean", "3rd Qu.", "Max.")
            rownames(qq) <- paste0(" V", seq_len(Nd(object)))
            print.table(qq, digits = 3)
        }
    } else {
        cat(" - None\n")
    }
}

summary_gdata <- function(object)
{
    ## Global model parameters
    cat("Global model parameters (gdata):\n")
    gdata <- data.frame(Parameter = names(object@gdata), Value = object@gdata)
    if (nrow(gdata) > 0) {
        print.data.frame(gdata, right = FALSE, row.names = FALSE)
    } else {
        cat(" - None\n")
    }
}

##' Brief summary of \code{SimInf_model}
##'
##' @param object The SimInf_model \code{object}
##' @return None (invisible 'NULL').
##' @export
##' @importFrom methods show
##' @examples
##' ## Create an 'SIR' model with 10 nodes and initialise
##' ## it to run over 100 days.
##' model <- SIR(u0 = data.frame(S = rep(99, 10),
##'                              I = rep(1, 10),
##'                              R = rep(0, 10)),
##'              tspan = 1:100,
##'              beta = 0.16,
##'              gamma = 0.077)
##'
##' ## Brief summary of the model
##' model
##'
##' ## Run the model and save the result
##' result <- run(model, threads = 1, seed = 1)
##'
##' ## Brief summary of the result. Note that 'U' and 'V' are
##' ## non-empty after running the model.
##' result
setMethod("show",
          signature(object = "SimInf_model"),
          function (object)
          {
              ## The model name
              cat(sprintf("Model: %s\n\n",
                          as.character(class(object))))

              cat(sprintf("Number of nodes: %i\n", Nn(object)))
              cat(sprintf("Number of compartments: %i\n", Nc(object)))
              cat(sprintf("Number of transitions: %i\n", Nt(object)))
              methods::show(object@events)

              cat("\n")
              show_U(object)
              show_V(object)
          }
)

##' Detailed summary of a \code{SimInf_model} object
##'
##' @param object The \code{SimInf_model} object
##' @param ... Additional arguments affecting the summary produced.
##' @return None (invisible 'NULL').
##' @export
setMethod("summary",
          signature(object = "SimInf_model"),
          function(object, ...)
          {
              ## The model name
              cat(sprintf("Model: %s\n\n",
                          as.character(class(object))))

              ## Nodes
              cat(sprintf("Number of nodes: %i\n\n", Nn(object)))

              ## Transitions
              cat("Transitions:\n")
              cat(paste0(" ", rownames(object@G), collapse = "\n"), "\n\n")

              summary_gdata(object)
              cat("\n")
              summary(object@events)
              cat("\n")
              summary_V(object)
              cat("\n")
              summary_U(object)
          }
)

##' Extract the events from a \code{SimInf_model} object
##'
##' @param model The \code{model} to extract the events from.
##' @return \code{SimInf_events} object.
##' @export
##' @examples
##' ## Create an SIR model that includes scheduled events.
##' model <- SIR(u0     = u0_SIR(),
##'              tspan  = 1:(4 * 365),
##'              events = events_SIR(),
##'              beta   = 0.16,
##'              gamma  = 0.077)
##'
##' ## Extract the scheduled events from the model and
##' ## display summary
##' summary(events(model))
##'
##' ## Extract the scheduled events from the model and
##' ## plot them
##' plot(events(model))
events <- function(model)
{
    ## Check model argument
    if (missing(model))
        stop("Missing 'model' argument")
    if (!is(model, "SimInf_model"))
        stop("'model' argument is not a 'SimInf_model'")
    model@events
}
