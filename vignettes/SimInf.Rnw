%% -*- mode: LaTeX; coding: utf-8; -*-
\documentclass[nojss]{jss}

\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{blkarray}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{tabularx}

%% Macros for the 'Epidemiological modeling' section
\newcommand{\Connect}{\mathbb{C}}
\newcommand{\fatmu}{\boldsymbol{\mu}}
\newcommand{\fatnu}{\boldsymbol{\nu}}
\newcommand{\Intdom}{\mathbf{Z}}
\newcommand{\Ncompartments}{N_{c}}
\newcommand{\Ntransitions}{N_{t}}
\newcommand{\Nnodes}{N_{n}}
\newcommand{\Realdom}{\mathbf{R}}
\newcommand{\Stoich}{\mathbb{S}}
\newcommand{\X}{\mathbb{X}}

% *** use this command to write comments; it is easy to spot in the text!
\newcommand{\comment}[1]{\textcolor{blue}{\{#1\}}}
\newcommand{\margincomment}[1]{{\textcolor{blue}*} \marginpar{\textcolor{blue}{*\{#1\}}}}

\author{Stefan Widgren\\National Veterinary Institute\\Sweden \And
  Pavol Bauer\\Uppsala University\\Sweden \And
  Stefan Engblom\\Uppsala University\\Sweden}

\Plainauthor{Stefan Widgren, Pavol Bauer, Stefan Engblom}

\title{\pkg{SimInf}: An \proglang{R} package for Data-driven
  Stochastic Disease Spread Simulations}

\Plaintitle{SimInf: An R package for Data-Driven Stochastic Disease
  Spred Simulations}

\Shorttitle{\pkg{SimInf}: Data-driven Stochastic Disease Spread
  Simulations}

\Abstract{

  Livestock movements are critical for the spread of many infectious
  diseases in animal populations.  The use of real livestock data
  allows for disease spread modeling that incorporates the
  time-varying contact network and the population demographic.  This
  paper introduces \pkg{SimInf}, an efficient and general framework
  for stochastic spatio-temporal disease-spread modelling over a
  temporal network of connected nodes.  It integrates within-node
  infection dynamics as continuous-time Markov chains and livestock
  data as scheduled events.  The core simulation solver is implemented
  in \proglang{C} and uses \proglang{OpenMP} to divide work over
  multiple processors.  We provide a technical description of the
  framework, how to use a built-in model, demonstrate a case study and
  finally how to extend the framework with a user defined model.

}

\Keywords{computational epidemiology, discrete-event simulation,
  multicore implementation, stochastic modeling}
\Plainkeywords{computational epidemiology, discrete-event simulation,
  multicore implementation, stochastic modeling}

\Address{
  Stefan Widgren\\
  Department of Disease Control and Epidemiology\\
  National Veterinary Institute\\
  SE-751 89 Uppsala, Sweden\\
  E-mail: \email{stefan.widgren@sva.se}\\
  URL: \url{http://www.sva.se}\\
  \\
  Pavol Bauer\\
  Division of Scientific Computing\\
  Department of Information Technology\\
  Uppsala University\\
  SE-751 05 Uppsala, Sweden\\
  E-mail: \email{pavol.bauer@it.uu.se}\\
  \\
  Stefan Engblom\\
  Division of Scientific Computing\\
  Department of Information Technology\\
  Uppsala University\\
  SE-751 05 Uppsala, Sweden\\
  E-mail: \email{stefane@it.uu.se}
}

<<echo=false, results=hide>>=
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
@

\begin{document}

\SweaveOpts{engine=R,eps=FALSE,height=5,width=10}
%\VignetteIndexEntry{SimInf: An R package for Data-Driven Stochastic Disease Spred Simulations}
%\VignetteDepends{SimInf,lattice}
%\VignetteKeywords{computational epidemiology, discrete-event simulation, multicore implementation, stochastic modeling}
%\VignettePackage{SimInf}

%**************************************************************************

\section{Introduction}

Livestock movements are an important transmission route for many
infectious diseases and can transfer infectious individuals between
holdings over large distances \citep{Danon2011}.  The livestock
movements between holdings can be represented as a temporal network
with nodes coupled by directed edges and the time when each edge was
active \citep{Holme2012}.  The temporal network of livestock movements
forms a complex system with dynamical properties in the topology,
connectivity and intensity \citep{Bajardi2011, Dutta2014}.  These
properties are important for the disease spread \citep{Shirley2005,
  Buettner2014}.  The use of real livestock data allows for disease
spread modeling that incorporates the time-varying contact network and
the population demographics.  It is also desirable to have a framework
that allows for a flexible and extendable specification of the disease
model to handle indirect or direct transmission routes and various
disease states.

In this work, we present an efficient and flexible framework for
spatio-temporal disease spread modeling.  We have developed a
discrete-event simulator, \pkg{SimInf}, that divides work among
multiple processors available in standard computers.  The model
integrates infection dynamics as continuous-time Markov chains and
available data such as animal movements, births, slaughter or aging
are incorporated as scheduled events.  One of our design goal was to
make \pkg{SimInf} completely extendable and allow for growth in
available models and specialized solvers through contributions from
the community.  Using compiled \proglang{C} code, rather than
interpreted \proglang{R} code, for the transition-rate functions
ensures maximum efficiency when simulating the model.  To simplify the
process of compiling the required \proglang{C} code of the models, the
\proglang{R} package configuration automatically include these files
for compilation during package installation.

The paper is organized as follows.  In \S\ref{sec:modeling} we
summarize the mathematical foundation for our framework.  Section
\S\ref{sec:framework} gives a technical description of the simulation
framework.  In \S\ref{sec:illustration} we illustrate the use of the
package by a worked example.  Finally, in \S\ref{sec:demo} we
demonstrate a realistic large-scale use case which also serve as an
explanation of how to extend \pkg{SimInf} with user-defined models.

%**************************************************************************

\section{Epidemiological modeling}
\label{sec:modeling}

In the following section, we give a brief overview of the
epidemiological modeling framework employed in \pkg{SimInf} and we
refer to \citep{Bauer2016} for further details.

Below we distinguish between local dynamics, that describe the
evolution of a single node, for example, a herd, and the global
dynamics, which describes the system at network level.

\subsection{Local dynamics}

We describe the state of a single node with a \emph{state vector}
$X_{t} = X(t) \in \Intdom_{+}^{\Ncompartments}$, which counts the
number of individuals at each of $\Ncompartments$ compartments at time
$t$.  The transitions between compartments are stochastic and
described by the transition matrix $\Stoich \in
\Intdom^{\Ncompartments \times \Ntransitions}$ as well as the
transition intensity $R: \Intdom_{+}^{\Ncompartments} \to
\Realdom_{+}^{\Ntransitions}$, assuming $\Ntransitions$ different
transitions.  We can then form a \textit{random counting measure}
$\mu_{k}(dt) = \mu(R_{k}(X(t-)); \, dt)$ that is associated with the
Poisson process for the $k$th intensity $R_{k}(X(t-)$, which in turn
depends on the state prior to the transition at time $t$, namely
$X(t-)$.

The local dynamics is then described by a stochastic differential
equations (SDE) with jumps,
\begin{align}
  \label{eq:vectorJSDE}
  dX_{t} &= \Stoich\fatmu(dt),
\end{align}
where $\fatmu(dt)$ is a vector measure built up from scalar counting
measures $\fatmu(dt) = [\mu_{1}(dt),\ldots,$
  $\mu_{\Ntransitions}(dt)]^\top$.

As an example, the transitions between a susceptible and an infected
compartment can be modeled as
\begin{align}
\label{eq:sirtrans}
  &\left. \begin{array}{rl}
    S+I &\xrightarrow{\beta} 2I \\
    I &\xrightarrow{\gamma} S \\
  \end{array} \right\}.
  \intertext{With a state vector consisting of two compartments $X =
    [S,I]$ we can then write the transition matrix and intensity
    vector as}
  \label{eq:SIRstoich}
    \Stoich &= \left[ \begin{array}{rr}
        -1 & 1 \\
        1  & -1
      \end{array} \right], \\
    R(x) &= [\beta x_{1}x_{2},\gamma x_{2}]^\top.
\end{align}

If a transition occurs, the state vector is altered by the transition
matrix as
\begin{align}
   X_{t}=X_{t-}+\Stoich_k,
\end{align}
assuming that $k$ is the index of the transition that occurred at time
$t$.

\subsection{Global dynamics}

To extend the local dynamics to a network model consisting of
$\Nnodes$ nodes we first define a state matrix $\X \in
\Intdom_{+}^{\Ncompartments \times \Nnodes}$ and then extend
Equation~\ref{eq:vectorJSDE} to
\begin{align}
  \label{eq:local}
  d\X^{(i)}_{t} &= \Stoich\fatmu^{(i)}(dt),
\end{align}
where $i \in \{1,...,\Nnodes\}$ is the node index.

We then consider $\Nnodes$ nodes being the vertices of an undirected
graph $\mathcal{G}$ with interactions defined in terms of the counting
measures $\fatnu^{(i,j)}$ and $\fatnu^{(j,i)}$.  Here $\fatnu^{(i,j)}$
represents the state changes due to an inflow of individuals from node
$i$ to node $j$, and $\fatnu^{(j,i)}$ represents an inflow of
individuals from node $j$ to node $i$, assuming node $j$ being in the
connected component $C(i)$ of node $i$, and vice versa.

The network dynamics is then written as
\begin{align}
  \label{eq:global}
  d\X^{(i)}_{t} &= -\sum_{j \in C(i)} \Connect\fatnu^{(i,j)}(dt)+
  \sum_{j; \, i \in C(j)} \Connect\fatnu^{(j,i)}(dt),
\end{align}

which in combination with Equation~\ref{eq:local} leads to the overall
dynamics
\begin{align}
  \label{eq:master}
  d\X^{(i)}_{t} &= \Stoich\fatmu^{(i)}(dt)-
  \sum_{j \in C(i)} \Connect\fatnu^{(i,j)}(dt)+
  \sum_{j; \, i \in C(j)} \Connect\fatnu^{(j,i)}(dt).
\end{align}

Note that $\fatnu^{(i,j)}$ and $\fatnu^{(j,i)}$ may be equivalently
defined for deterministic events given by external data using
an equivalent construction in terms of Dirac measures.

This general model can be further extended with continuous state
variables that may be affected by both local and global dynamics.
Consult \cite{Bauer2016} for further details.

\subsection{Numerical method}

In \pkg{SimInf}, we solve Equation~\ref{eq:master} by splitting the
local update scheme, Equation~\ref{eq:local}, from the global update
scheme, Equation~\ref{eq:global}, and evaluating each scheme
individually.  As a consequence, the time is discretized as $0 = t_{0}
< t_{1} < t_2 < \cdots$, which is practical as external data has to be
incorporated at some finitely resolved time steps.  The numerical
method can then be written per node $i$ as
\begin{align}
  \label{eq:numstep3}
  \tilde{\X}_{n+1}^{(i)} &= \X_{n}^{(i)} + \int^{t_{n+1}}_{t_n}
  \Stoich \fatmu^{(i)}(\tilde{\X}^{(i)}(s-); \; ds), \\
  \label{eq:numstep4}
  \X_{n+1}^{(i)} &= \tilde{\X}^{(i)}_{n+1}-\int^{t_{n+1}}_{t_n} \sum_{j \in C(i)}
  \Connect\fatnu^{(i,j)}(\X^{(i)}(s-); \; ds) \\
  \nonumber
  &\phantom{= \tilde{\X}^{(i)}_{n+1}}+\int^{t_{n+1}}_{t_n} \sum_{j; \, i \in C(j)}
  \Connect\fatnu^{(j,i)}(\X^{(j)}(s-); \; ds).
\end{align}

In this scheme, Equation~\ref{eq:numstep3} forms the stochastic step,
that is in practice computed by the Gillespie method
\citep{Gillespie1977}.  Equation~\ref{eq:numstep4} is the data step,
where externally scheduled events are incorporated.  Note that the
stochastic step evolves at continuous time increments in the interval
$[t_n,t_{n+1}]$, and the data step operates only on the final state
$\tilde{\X}$ at $t_{n+1}$.  At this point, the simulator may also
evaluate a \textit{post-time-step} function, which triggers additional
processing steps, as for example, the update of continuous state
variables.

%**************************************************************************

\section{Technical description of the simulation framework}
\label{sec:framework}

The overall design of \pkg{SimInf} was inspired and partly adapted
from the Unstructured Mesh Reaction-Diffusion Master Equation (URDME)
framework \citep{Engblom2009, Drawert2012}.  \pkg{SimInf} is a general
software framework for data-driven modeling and simulation of
stochastic disease-spread in a complex network of connected nodes.  In
particular, the transition rates and the transition topology are
specified using a compiled language \proglang{C} and \proglang{R}
matrices, respectively.  The overall modular design makes extensions
easy to handle and since the simulation engine is written in a
compiled language, the efficiency of the simulator is very high.

The \pkg{SimInf} package is available via the Comprehensive
\proglang{R} Archive Network (CRAN) at
\mbox{\url{https://CRAN.R-project.org/package=SimInf}} and is loaded
in \proglang{R} with the following command

<<load-SimInf>>=
library("SimInf")
@

\subsection{Overview}

The \pkg{SimInf} \proglang{R} package uses object oriented programming
with \code{S4} classes \citep{Chambers2008} to define objects with
logical layers connected by well-defined interfaces for different
modeling scenarios.  The two \code{S4} classes \code{SimInf\_model}
and \code{SimInf\_events} are central and provide the basis for the
flexible framework to perform efficient simulations in compiled
\proglang{C} code of built-in or user-defined models.  The
\code{SimInf\_model} class contains slots
(Table~\ref{table:SimInf:model}) to data structures that define the
disease-spread model and one slot \code{events} associated to a
\code{SimInf\_events} object, which contains slots
(Table~\ref{table:scheduled:events}) to incorporate and process
scheduled events.  Furthermore, the \code{SimInf\_model} object also
contains the output trajectory after running the core simulation
solver on the disease-spread model.

All disease-spread models in \pkg{SimInf} contains the \code{S4} class
\code{SimInf\_model}.  Moreover, the built-in disease-spread models
have a generating function \citep{Chambers2008}, with the same name as
the model, which check parameters and initialize the necessary data
structures for that specific model.  After the model is initialized,
the simulation is started with a call to the \code{run} method.  To
facilitate post-processing and visualization of output data, the
built-in models provide several utility functions, for example,
\code{susceptible}, \code{infected}, \code{prevalence} and
\code{plot}.

\begin{table}
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule
    Slot & Description\\
    \midrule

    \code{S} & Each column corresponds to a state transition, and
    execution of state transition $j$ amounts to adding the \code{S[,
        j]} column to the state vector \code{u[, i]} of node $i$ where
    the transition occured.  Sparse matrix ($N_c \times N_t$) of
    object class \code{dgCMatrix}.\\

    \code{G} & Dependency graph that indicates the transition rates
    that need to be updated after a given state transition has
    occured.  A non-zero entry in element \mbox{\code{G[i, j]}}
    indicates that transition rate $i$ needs to be recalculated if the
    state transition $j$ occurs.  Sparse matrix ($N_t \times N_t$) of
    object class \code{dgCMatrix}.\\

    \code{tspan} & A vector of increasing time points where the state
    of each node is to be returned.\\

    \code{U} & The result matrix with the number of individuals in
    each compartment in every node.  \mbox{\code{U[, j]}} contains the
    number of individuals in each compartment at \code{tspan[j]}.
    \mbox{\code{U[1:Nc, j]}} contains the number of individuals in
    each compartment in node $1$ at \code{tspan[j]}.
    \mbox{\code{U[(Nc + 1):(2 * Nc), j]}} contains the number of
    individuals in each compartment in node $2$ at \code{tspan[j]}
    etc.  Integer matrix ($N_n N_c \times
    \text{length}(\text{tspan})$).\\

    \code{U\_sparse} & It is possible to run the simulator and write
    the number of individuals in each compartment to the
    \code{U\_sparse} sparse matrix (\code{dgCMatrix}), which can save
    a lot of memory if the model contains many nodes and time-points,
    but where only a few of the data points are of interest.  If
    \code{U\_sparse} is non-empty when \code{run} is called, the
    non-zero entries in \code{U\_sparse} indicates where the number of
    individuals should be written to \code{U\_sparse}.  The layout of
    the data in \code{U\_sparse} is identical to \code{U}.  Please
    note that the data in \code{U\_sparse} is numeric and that the
    data in \code{U} is integer.\\

    \code{u0} & The initial number of individuals in each compartment
    in every node.  Integer matrix ($N_c \times N_n$).\\

    \code{V} & The result matrix for the real-valued contininuous
    state.  \mbox{\code{V[, j]}} contains the real-valued state of the
    system at \code{tspan[j]}.  Numeric matrix ($N_n N_{ld} \times
    \text{length}(\text{tspan})$).\\

    \code{V\_sparse} & It is possible to run the simulator and write
    the real-valued continuous state to the \code{V\_sparse} sparse
    matrix (\code{dgCMatrix}), which can save a lot of memory if the
    model contains many nodes and time-points, but where only a few of
    the data points are of interest.  If \code{V\_sparse} is non-empty
    when \code{run} is called, the non-zero entries in
    \code{V\_sparse} indicates where the real-valued continuous state
    should be written to \code{V\_sparse}.  The layout of the data in
    \code{V\_sparse} is identical to \code{U}.\\

    \code{v0} & The initial value for the real-valued continuous
    state.  Numeric matrix ($N_{ld} \times N_n$).\\

    \code{ldata} & A numeric matrix with local data specific to each
    node.  The column \code{ldata[, j]} contains the local data vector
    for node $j$.  The local data vector is passed as an argument to
    the transition rate functions and the post time step function.\\

    \code{gdata} & A numeric vector with global data that is common to
    all nodes.  The global data vector is passed as an argument to the
    transition rate functions and the post time step function.\\

    \code{events} & Scheduled events to modify the discrete state of
    individuals in a node at a pre-defined time $t$.  \code{S4} class
    \code{SimInf\_events}, see \S\ref{sec:events} and
    Table~\ref{table:scheduled:events}.\\

    \code{C\_code} & Character vector with optional model \proglang{C}
    code, see \S\ref{sec:extend}.  If non-empty, the \proglang{C} code
    is written to a temporary file when the \code{run} method is
    called.  The temporary file is compiled and the resulting DLL is
    dynamically loaded.  The DLL is unloaded and the temporary files
    are removed after running the model.\\

    \bottomrule
  \end{tabularx}
  \caption{Description of the slots in the S4 class
    \code{SimInf\_model} that defines the epidemiological model.
    $N_t$ is the number of state transitions in the model.  $N_c$ is
    the number of compartments in the model.  $N_n$ is the number of
    nodes in the model.  $N_{ld}$ is the number of local data specific
    to each node and equals \code{dim(ldata)[1]}.}
  \label{table:SimInf:model}
\end{table}

\subsection{Specification of an epidemiological model}
\label{sec:model}

The within-node disease spread model in \pkg{SimInf} is specified as a
compartment model with the individuals divided into compartments
defined by discrete disease statuses.  The model is defined by the
slots in the \code{S4} class \code{SimInf\_model}
(Table~\ref{table:SimInf:model}).  The compartments contains the
number of individuals in each of the $N_c$ disease states in every
$N_n$ nodes.

The stochastic step Equation~\ref{eq:numstep3} contains $N_t$ state
transitions and is processed using the two slots, \code{S} and
\code{G}.  The \code{S} slot is the state-change matrix ($N_c \times
N_t$) that determines how to change the number of individuals in the
compartments of a node when the $j^{th}$ state transition occurs,
where $1 \le j \le N_t$.  Each row corresponds to one compartment and
each column to a state transition.  Let \code{u[, i]} be the number of
individuals in each compartment in node $i$ at time $t_i$.  To move
simulation time forward in node $i$ to $t_i = t_i + \tau_i$, the
vector \code{u[, i]} is updated according to the $j^{th}$ transition
by adding the state-change vector \code{S[, j]} to \code{u[, i]}.
After updating \code{u[, i]}, the transition rates must be
recalculated to obtain the time to the next event.  However, a state
transition might not need all transition rates to be recalculated.
The dependency graph \code{G} is a matrix ($N_t \times N_t$) that
determines which transition rate that needs to be recalculated.  A
non-zero entry in element \code{G[k, j]} indicates that transition
rate \code{k} needs to be recalculated if the $j^{th}$ state
transition occurs, where \mbox{$1 \le$ \code{k} $\le N_t$}.

\begin{table}
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule Slot & Description\\ \midrule

    \code{E} & Each row corresponds to one compartment in the model.
    The non-zero entries in a column indicates the compartments to
    include in an event.  Sparse matrix of object class
    \code{dgCMatrix}.\\

    \code{N} & Each row represents one compartment in the model and
    the values determine how to move sampled individuals in
    \textit{internal transfer} and \textit{external transfer} events.
    Integer matrix.\\

    \code{event} & Type of event: 0) \textit{exit}, 1) \textit{enter},
    2) \textit{internal transfer}, and 3) \textit{external transfer}.
    Other values are reserved for future event types and not supported
    by the current default core solver.  Integer vector.\\

    \code{time} & Time of the event.  Integer vector.\\

    \code{node} & The node that the event operates on.  Also the
    source node for an \textit{external transfer} event.  Integer
    vector.  $1 \le$ \code{node[i]} $\le N_n$.\\

    \code{dest} & The destination node for an \textit{external
      transfer} event, equals $0$ for the other event types.  Integer
    vector.\\

    \code{n} & The number of individuals affected by the event.
    Integer vector.  \code{n[i]} $\ge 0$.\\

    \code{proportion} & If \code{n[i]} equals zero, the number of
    individuals affected by \code{event[i]} is calculated by summing
    the number of individuls in the compartments determined by
    \code{select[i]} and multiplying with \code{proportion[i]}.
    Numeric vector.  $0 \le$ \code{proportion[i]} $\le 1$.\\

    \code{select} & Column $j$ in the event matrix $E$ that determines
    the compartments that the event operates on.  Integer vector.\\

    \code{shift} & Column $k$ in the shift matrix $N$ that determines
    how individuals in \textit{internal transfer} and \textit{external
      transfer} events are shifted to enter another compartment.
    Integer vector.\\

    \bottomrule
  \end{tabularx}
  \caption{Description of the slots in the S4 class
    \code{SimInf\_events} that holds data to process events.  Each
    index, \code{i}, of the vectors represent one event.  $N_n$ is the
    number of nodes in the model.}
  \label{table:scheduled:events}
\end{table}

Model-specific data that is passed to the transition-rate functions
and the post time-step function are stored in the three slots:
\code{ldata} and \code{gdata} in the \code{SimInf\_model} object.  The
\code{ldata} matrix holds local data for each node where \code{ldata[,
    i]} is the data vector for node $i$.  Data that is global i.e.,
shared between nodes, is stored in the \code{gdata} vector.

The \code{events} slot in the \code{SimInf\_model} holds data to
process the scheduled events, further described in \S\ref{sec:events}.

During simulation of one trajectory, the state of the system is
written to the two matrices \code{U} and \code{V}.  This happens at
each occasion the simulation time passes a time point in \code{tspan},
a vector of increasing time points.  The first and last element in
\code{tspan} determines the start- and end-point of the simulation.
The column \code{U[, m]} contains the number of individuals in each
compartment in every node at \code{tspan[m]}, where $1 \le$ \code{m}
$\le$ \code{length(tspan)}.  The first $N_c$ rows in \code{U} contains
the compartments of the first node.  The next $N_c$ rows contains the
compartments of the second node etc.  The \code{V} matrix contains
output from continuous state variables.  The column \code{V[, m]}
contains the values at \code{tspan[m]}.  The rows are grouped per node
and the number of rows per node is determined by the number of
continuous state variables in that specific model.  It is also
possible to configure the simulator to write the state of the system
to the sparse matrices \code{U\_sparse} and \code{V\_sparse}, which
can save a lot of memory if the model contains many nodes and
time-points, but where only a few of the data points are of interest.
In order to use this feature, call the \code{U} and \code{V} methods
(before running a trajectory) with a sparse matrix with non-zero
entries where the simulator should write the state of the system.  The
initial state in each node is specified by the two matrices \code{u0}
and \code{v0} where \code{u0[, i]} is the initial number of
individuals in each compartment at node $i$ and \code{v0[, i]} is the
initial continuous state in node $i$.

\begin{table}
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule
    Argument & Description\\
    \midrule
    \code{v\_new} & The continuous state vector in the node after the
    post time step.  Exists only in \code{PTSFun}.\\
    \code{u} & The compartment state vector in the node.\\
    \code{v} & The current continuous state vector in the node.\\
    \code{ldata} & The local data vector for the node.\\
    \code{gdata} & The global data vector.\\
    \code{node} & The node index.  Note the node index is zero-based
    i.e., the first node is $0$.\\
    \code{t} & Current time in the simulation.\\
    \bottomrule
  \end{tabularx}
  \caption{Description of the arguments to the transition rate
    functions (\code{TRFun}) and the post time step function
    (\code{PTSFun}).}
  \label{table:arguments}
\end{table}

\subsection{Specification of scheduled events}
\label{sec:events}

The scheduled events are used to modify the discrete state of
individuals in a node at a pre-defined time $t$.  There are four
different types of events; \textit{enter}, \textit{internal transfer},
\textit{external transfer} and \textit{exit}.  The \textit{enter}
event, adds individuals to a node, for example, due to births.  The
\textit{internal transfer} event changes the number of individuals in
the compartments within one node, for example, aging of individuals in
a model with several age compartments or vaccination to move
individuals to a vaccinated compartment.  The \textit{external
  transfer} event moves individuals from compartments in one node to
compartments in a destination node.  Finally, the \textit{exit} event
removes individuals from a node, for example, due to slaughter.  The
event types are classified into those that operate on the compartments
of a single node $E_1 = \{\text{\textit{enter}, \textit{internal
    transfer}, \textit{exit}}\}$ and those that operate on the
compartments of two nodes $E_2 = \{\text{\textit{external
    transfer}}\}$.  The parallel algorithm processes these two classes
of events differently.  The scheduled events are processed when
simulation time reaches the time for any of the events.  Events that
are scheduled at the same time are processed in the following order:
\textit{exit}, \textit{enter}, \textit{internal transfer} and
\textit{external transfer}.

The S4 class \code{SimInf\_events} contains slots with data structures
to process events (Table~\ref{table:scheduled:events}).  The slots
\code{event}, \code{time}, \code{node}, \code{dest}, \code{n},
\code{proportion}, \code{select} and \code{shift}, are vectors of
equal length.  These vectors hold data to process one event: \code{e},
where $1 <$ \code{e} $\leq$ \code{length(event)}.  The event type and
the time of the event are determined by \code{event[e]} and
\code{time[e]}, respectively.  The compartments that \code{event[e]}
operates on, are specified by \code{select[e]} together with the slot
\code{E}.  Each row $\{1, 2, ..., N_c\}$ in the sparse matrix
\code{E}, represents one compartment in the model.  Let \code{s <-
  select[e]}, then each non-zero entry in the column \code{E[, s]}
includes that compartment in the \code{event[e]} operation.

\begin{table}
  \small
  \begin{tabular}{l c c c c c c c c}
    \toprule
    Action & \code{event} & \code{time} & \code{node} & \code{dest} &
    \code{n} & \code{proportion} & \code{select} & \code{shift} \\
    \midrule
    Exit individuals in $S_1$ and $I_1$  & 0 & t & x & 0 & n & 0 & 4 & 0\\
    Exit individuals in $S_2$ and $I_2$  & 0 & t & x & 0 & n & 0 & 5 & 0\\
    Exit individuals in $S_3$ and $I_3$  & 0 & t & x & 0 & n & 0 & 6 & 0\\
    Enter individuals in $S_1$ and $I_1$ & 1 & t & x & 0 & n & 0 & 1 & 0\\
    Enter individuals in $S_2$ and $I_2$ & 1 & t & x & 0 & n & 0 & 2 & 0\\
    Enter individuals in $S_3$ and $I_3$ & 1 & t & x & 0 & n & 0 & 3 & 0\\
    Age individuals in $S_1$ and $I_1$   & 2 & t & x & 0 & n & 0 & 4 & 1\\
    Age individuals in $S_2$ and $I_2$   & 2 & t & x & 0 & n & 0 & 5 & 2\\
    Move individuals in $S_1$ and $I_1$  & 3 & t & x & y & n & 0 & 4 & 0\\
    Move individuals in $S_2$ and $I_2$  & 3 & t & x & y & n & 0 & 5 & 0\\
    Move individuals in $S_3$ and $I_3$  & 3 & t & x & y & n & 0 & 6 & 0\\
    \bottomrule
  \end{tabular}
  \caption{Examples of the specification of a single row of scheduled
    event data in the \code{SISe3\_sp} model to add, move or remove
    individuals during the simulation.}
  \label{table:SISe3_sp:events}
\end{table}

\subsubsection{Processing of an enter event}

The \textit{enter} event adds \code{n[e]} individuals to one
compartment at \code{node[e]}.  The compartment is specified by a
non-zero entry in the row for the compartment in column \code{E[, s]}.
Please note that, if the column \code{E[, s]} contains several
non-zero entries, the individuals are added to the compartment
represented by the first non-zero row in column \code{E[, s]}.  The
values of \code{dest[e]}, \code{proportion[e]} and \code{shift[e]},
described below, are not used when processing an \textit{enter} event.
See Figure~\ref{fig:enter} for an illustration of a scheduled
\textit{enter} event.

\subsubsection{Processing of an internal transfer event}

The \textit{internal transfer} event moves \code{n[e]} individuals
into new compartments within \code{node[e]}.  However, if \code{n[e]}
equals zero, the number of individuals to move is calculated by
multiplying the \code{proportion[e]} with the total number of
individuls in the compartments represented by the non-zero entries in
column \mbox{\code{E[, s]}}.  The individuals are then proportionally
sampled and removed from the compartments specified by \code{E[, s]}.
The next step is to move the sampled individuals to their new
compartment using the matrix \code{N} and \code{shift[e]}, where
\code{shift[e]} specifies which column in \code{N} to use.  Each row
$\{1, 2, ..., N_c\}$ in \code{N}, represents one compartment in the
model and the values determine how to move sampled individuals before
adding them to \code{node[e]} again.  Let \code{q <- shift[e]}, then
each non-zero entry in \code{N[, q]} defines the number of rows to
move sampled individuals from that compartment i.e., sampled
individuals from comparment \code{p} are moved to compartment
\code{N[p, q] + p}, where $1 \leq$ \code{N[p, q] + p} $\le N_c$.  The
value of \code{dest[e]}, described below, is not used when processing
an \textit{internal transfer} event.  See Figure~\ref{fig:internal}
for an illustration of a scheduled \textit{internal transfer} event.

\begin{figure}
  \begin{center}
    \includegraphics[width=0.67\linewidth]{img/exit.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{exit} event (event = 0)
    in the \code{SISe3\_sp} model at time = 4.  The removal of one
    individual in the third age category $\{S_3, I_3\}$ from node 14.
    Interpreting the figure from left to right: \textit{i)} A single
    row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14; \code{E[, 6]} is
    the 6$^{th}$ column in the select matrix that determines which
    compartments (age categories) that are eligible for sampling.
    \textit{iii)} The operation of randomly sampling one individual (n
    = 1) to move from the compartments selected in step \textit{ii}.
    \textit{iv)} The resultant state of node 14 after subtracting the
    sampled individual in step \textit{iii} from node 14.
    $^\dag$\code{dest} and $^\S$\code{shift} are not used in a
    scheduled \textit{exit} event.  $^\ddag$\code{proportion} is not
    used when $n > 0$.  \label{fig:exit}}

  \vspace*{\floatsep}

  \begin{center}
    \includegraphics[width=0.6\linewidth]{img/enter.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{enter} event (event =
    1) in the \code{SISe3\_sp} model at time = 4.  Add three
    susceptible individuals to the first age category $\{S_1\}$ in
    node 14.  Interpreting the figure from left to right: \textit{i)}
    A single row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14.  \textit{iii)}
    \code{E[, 1]} is the first column in the select matrix that
    determines which compartments (age categories) the new individuals
    are added.  \textit{iv)} The resultant state of node 14 after
    adding the individuals in step \textit{iii}.  $^\dag$\code{dest},
    $^\ddag$\code{proportion} and $^\S$\code{shift} are not used in a
    scheduled \textit{enter} event.  \label{fig:enter}}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=0.8\linewidth]{img/internal.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{internal transfer}
    event (event = 2) in the \code{SISe3\_sp} model at time = 4.  The
    ageing of three individuals in the first age category $\{S_1,
    I_1\}$.  Interpreting the figure from left to right: \textit{i)} A
    single row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14; \code{E[, 4]} is
    the 4$^{th}$ column in the select matrix that determines which
    compartments (age categories) that are eligible for sampling.
    \textit{iii)} The operation of randomly sampling three individuals
    (n = 3) to age from the compartments selected in step \textit{ii}.
    \textit{iv)} The shift operation applies the shift specified in
    column 1 of the shift matrix (\code{N}) to the individuals sampled
    in step \textit{iii}.  \textit{v)} The resultant state of node 14
    after subtracting the sampled individuals in step \textit{iii} and
    adding the individuals after the shift operation in step
    \textit{iv}.  $^\dag$\code{dest} is not used in \textit{internal
      transfers}.  $^\ddag$\code{proportion} is not used when $n >
    0$.  \label{fig:internal}}

  \vspace*{\floatsep}

  \begin{center}
    \includegraphics[width=0.66\linewidth]{img/external.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{external transfer}
    event (event = 3) in the \code{SISe3\_sp} model at time = 4.  The
    movement of one individual in the third age category $\{S_3,
    I_3\}$ from node 14 to destination node 23.  Interpreting the
    figure from left to right: \textit{i)} A single row of the event
    data operating on node 14 and destination node 23.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14; \code{u[, 23]} is
    the current state of the destination node 23; \code{E[, 6]} is the
    6$^{th}$ column in the select matrix that determines which
    compartments (age categories) that are eligible for sampling.
    \textit{iii)} The operation of randomly sampling one individual (n
    = 1) to move from the compartments selected in step \textit{ii}.
    \textit{iv)} The resultant state of node 14 and destination node
    23 after subtracting the sampled individuals in step \textit{iii}
    from node 14 and adding them to destination node 23.
    $^\dag$\code{shift} can be used in a scheduled \textit{external
      transfer} event, see
    Figure~\ref{fig:external:shift}. $^\ddag$\code{proportion} is not
    used when $n > 0$.  \label{fig:external}}
\end{figure}

\subsubsection{Processing of an external transfer event}

The \textit{external transfer} event moves individuals from
\code{node[e]} to \code{dest[e]}.  The sampling of individuals from
\code{node[e]} is performed in the same way as for an \textit{internal
  transfer} event.  The compartments at \code{node[e]} are updated by
subtracting the sampled individuals while adding them to the
compartments at \code{dest[e]}.  The sampled individuals are added to
the same compartments in \code{dest[e]} as in \code{node[e]}, unless
\code{shift[e]} $> 0$.  In that case, the sampled individuals change
compartments according to \code{N} as described in processing an
\textit{internal transfer} event before adding them to \code{dest[e]}.
See figures \ref{fig:external} and \ref{fig:external:shift} for
illustrations of scheduled \textit{external transfer} events.

\subsubsection{Processing of an exit event}

The \textit{exit} event removes individuals from \code{node[e]}.  The
sampling of individuals from \code{node[e]} is performed in the same
way as for an \textit{internal transfer} event.  The compartments at
\code{node[e]} are updated by subtracting the sampled individuals.
The values of \code{dest[e]} and \code{shift[e]} are not used when
processing an \textit{exit} event.  See Figure~\ref{fig:exit} for an
illustration of a scheduled \textit{exit} event.

\subsection{Core simulation solver}

The \pkg{SimInf} package uses the ability to interface compiled code
from R \cite{Chambers2008}.  The solver is implemented in the compiled
language \proglang{C} \citep{Kernighan1988} and is called from
\proglang{R} using the \code{.Call()} interface \citep{Chambers2008}.
Using compiled rather than interpreted code ensures high performance
when running the model.  To improve performance further, the solver
uses \proglang{OpenMP} \citep{OpenMP2008} to divide work over multiple
processors and perform computations in parallel.  The solver uses the
GNU Scientific Library (GSL) \citep{Gallassi2009} to generate random
numbers for the simulation.

\subsubsection{Function pointers}

The flexibility of the solver is partly achieved by using function
pointers \citep{Kernighan1988}.  A function pointer is a variable that
stores the address of a function that can be used to invoke the
function.  This provides a simple way to incorporate model specific
functionality into the solver.  A model must define one transition
rate function for each state transition in the model.  These functions
are called by the solver to calculate the transition rate for each
state transition in each node.  The output from the transition rate
function depends only on the state of the system at the current time.
However, the output is unique to a model and data are for that reason
passed on to the function for the calculation.  Furthermore, a model
must define the post time step function.  This function is called once
for each node each time the simulation of the continuous-time Markov
chain reaches the next day (or, more generally, the next unit of time)
and after the $E_1$ and $E_2$ events have been proccessed.  The main
purpose of the post time step function is to allow for a model to
update continuous state variables in each node.

The transition rate function is defined by the data type \code{TRFun}
and the post time step function by the data type \code{PTSFun}.  These
data types are defined in the header file \texttt{'src/SimInf.h'} and
shown below.  The arguments \code{v\_new}, \code{u}, \code{v},
\code{ldata}, \code{gdata}, \code{node}, and \code{t} of the functions
are described in Table~\ref{table:arguments}.

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[language=C]
  typedef double (*TRFun)(const int *u, const double *v, const double *ldata,
                          const double *gdata, double t);

  typedef int (*PTSFun)(double *v_new, const int *u, const double *v,
                        const double *ldata, const double *gdata,
                        int node, double t);
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\subsubsection{Overview of the solver}

Here follows an overview of the steps in the solver to run one
trajectory, see Algorithm~\ref{alg:core} for pseudo-code and
\texttt{'src/core/SimInf\_solver.c'} for the source code.  The
simulation starts with a call to the \code{run} method with the model
as the first argument and optionally the number of threads and the
seed.  This method will first call the validity method on the model to
perform error-checking and then call a model specific \proglang{C}
function to initialize the function pointers to the transition rate
functions and the post time step function of the model.  Subsequently,
the simulation solver is called to run one trajectory using the model
specific data, the transition rate functions, and the post time step
function.  If the \code{C\_code} slot is non-empty, the \proglang{C}
code is written to a temporary file when the \code{run} method is
called.  The temporary file is compiled using \code{'R CMD SHLIB'} and
the resulting DLL is dynamically loaded.  The DLL is unloaded and the
temporary files are removed after running the model.  This is further
described in \S\ref{sec:extend}.

The solver simulates the trajectory in parallel if \proglang{OpenMP}
is available.  The default is to use all available threads.  However,
the user can specify the number of threads to use.  The solver divides
data for the $N_n$ nodes and the $E_1$ events over the number threads.
All $E1$ events that affect node $i$ is processed in the same thread
as node $i$ is simulated in.  The $E_2$ events are processed in the
main thread.

The solver runs the continuous-time Markov chain for each node $i$.
For every time step $\tau_i$, the count in the compartments at node
$i$ is updated according to the state transition that occured
(\S\ref{sec:model}).  The time to the next event is computed, after
recalculating affected transition rate functions (\S\ref{sec:model}).
When simulated time reaches the next day in node $i$ the $E_1$ events
are processed for that node (\S\ref{sec:events}).  The $E_2$ events
are processed when all nodes reaches the next day
(\S\ref{sec:events}).  Thereafter, the post time step function is
called to allow the model to incorporate model specific actions.  When
simulated time passes the next time in \code{tspan}, the count of the
compartments and the continuous state variables are written to
\code{U} and \code{V}.

%**************************************************************************

\section[Model construction and data analysis: Simple examples]{Model construction and data analysis: Simple examples}

\subsection[A first example: The SIR model]{A first example: The \code{SIR} model}
\label{sec:example-SIR}

This section illustrates the specification of the built-in \code{SIR}
model, which contains the three compartments susceptible (\code{S}),
infected (\code{I}) and recovered (\code{R}), where $\{S, I, R\}$
represents the number of individuals in each of the three
compartments, respectively.  The transmission route of infection to
susceptible individuals is through direct contact between susceptible
and infected individuals.  The \code{SIR} model has two state
transitions in each node $i$,
\begin{align}
\label{eq:SIR}
\begin{array}{rcl}
  S_i & \xrightarrow{\beta S_i I_i / (S_i+I_i+R_i)} & I_i, \\
  I_i &\xrightarrow{\gamma I_i} & R_i,
  \end{array}
\end{align}

where $\beta$ is the transmission rate and $\gamma$ is the recovery
rate.  The state change matrix \code{S} and the dependency graph
\code{G} for the \code{SIR} model are defined as follows

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=1.0\linewidth]{img/SIR.pdf}
  \end{center}
  \caption{Schematic representation of the \code{SIR} compartment
    model in two nodes.  The \code{SIR} model is defined by the three
    disease states susceptible (S), infected (I), and recovered (R).
    \textit{i)} State transitions between the $S$, $I$, and $R$
    compartments are modeled as a continuous-time discrete-state
    Markov process.  The other state transitions are due to scheduled
    events: \textit{ii)} \textit{enter} events, \textit{iii)}
    \textit{exit} events, and \textit{iv)} \textit{external transfer}
    events.  \label{fig:SIR-model}}
\end{figure}

{\small
\[
\mathbf{S} =
\begin{blockarray}{crr}
  & 1 & 2 \\
  \begin{block}{c(rr)}
    S & -1 &  0 \\
    I &  1 & -1 \\
    R &  0 &  1 \\
  \end{block}
\end{blockarray} \qquad
\mathbf{G} =
\begin{blockarray}{ccc}
  & 1 & 2 \\
  \begin{block}{c(rr)}
    S \rightarrow I & 1 & 1 \\
    I \rightarrow R & 1 & 1 \\
  \end{block}
\end{blockarray}
\]
}

The first step in creating an \code{SIR} model object is to define
\code{u0}, a \code{data.frame} with the initial condition i.e., the
number individuals in each compartmant when the simulation starts.  We
will start in a node with 100 individuals of which 1 is infected.

<<SIR-u0>>=
u0 <- data.frame(S = 99, I = 1, R = 0)
@

Next, we define the time period, over which we want to simulate the
disease spread.  This is a vector of integers in units of time or a
vector of dates.  You specify those time points in the vector that you
wish the model to return results for.  The model itself does not run
in discret time steps, but continuous time, so this vector affects
only the start and end points of the simulation and the results that
you receive from the model, not the internal calculations of disease
transitions through time.  In this example we simulate for 6 months
returning results every 7th day

<<SIR-tspan>>=
tspan <- seq(1, 6 * 30, by = 7)
@

Before we can simulate from the model, we need to specify the
transmission rate, $\beta$, and the recovery rate, $\gamma$.

<<SIR-model>>=
model <- SIR(u0 = u0, tspan = tspan, beta = 0.16, gamma = 0.077)
@

We are now ready to run the model with these parameters and simulate
data.  We use the \code{threads} and \code{seed} arguments for
reproducibility.

<<SIR-run>>=
result <- run(model, threads = 1, seed = 123)
@

The \code{result} object contains the number of individuals in each
compartment at the time points specified in \code{tspan} and can be
extracted using the \code{U} method.  The row names indicate the
compartments in the model and the colnames are the time points in
\code{tspan}.  Please note that the \code{U} matrix is truncated here
for readability.

<<SIR-U>>=
U(result)[, 1:10]
@

And then plot the results of the disease simulation in the single node
using

\begin{figure}[htb]
  \begin{center}
<<SIR-plot-proportion, fig=TRUE>>=
plot(result)
@
  \end{center}
  \caption{Example of simulated data from one realisation of the
    \code{SIR} model (Equation~\ref{eq:SIR}) in one node, starting
    with 99 susceptible, 1 infected, and 0 recovered
    individuals. \label{fig:SIR-proportion}}
\end{figure}

In order to run a simulation with multiple nodes we need to just add
those nodes to the initial \code{u0} \code{data.frame} that we
generate to start the model.  If you were doing your own modelling of
many nodes, you would have a \code{data.frame} of your node population
that you read from, for example, a spreadsheet.  For now we will just
add another nodes to the \code{data.frame} here in \proglang{R}.

<<SIR-multiple-nodes>>=
u0 <- data.frame(S = c(99, 90), I = c( 1,  2), R = c( 0,  0))
model <- SIR(u0 = u0, tspan = tspan, beta = 0.16, gamma = 0.077)
result <- run(model, threads = 1, seed = 123)
@

Inspect the \code{U} matrix, which now includes results from 2 nodes
above one another for each time point in the \code{tspan} vector.
Please note that the \code{U} matrix is truncated here for
readability.

<<SIR-U-multiple-nodes>>=
U(result)[, 1:10]
@

Because of the high performance of the simulator, we can easily expand
the model to include several hundreds or thousands of nodes, and still
run the simulations efficiently.  We will illustrate this by exploring
the dynamics, when perturbating the model parameters, of the
population- and between-node prevalence in 500 nodes after 75 days.
This can be achieved, using the built-in \code{run\_outer} method.  It
takes a \code{SimInf\_model}, a \code{formula} specifying the model
\code{gdata} parameters to perturbate, \code{x} and \code{y} arrays
with values of how much to perturbate the parameters, and a callback
function \code{FUN}.  The model \code{gdata} parameters on the
right-hand-side of the formula are scaled with \code{y}.  Similarily,
the \code{gdata} parameters on the left-hand-side of the formula are
scaled with \code{x}.  For each combination of \code{x} and \code{y},
the model parameters are scaled and the function \code{FUN} called
with the perturbated model.

<<SIR-run-outer>>=
u0 <- data.frame(S = rep(99, 500), I = rep(1, 500), R = rep(0, 500))
model <- SIR(u0, 1:75, beta = 0.16, gamma = 0.077)
x <- seq(from = 0.2, to = 1.8, by = 0.05)
y <- seq(from = 0.2, to = 1.1, by = 0.05)
pop <- run_outer(x, y, model, gamma ~ beta,
function(model) {prevalence(run(model), "pop")[75]})
bnp <- run_outer(x, y, model, gamma ~ beta,
function(model) {prevalence(run(model), "bnp")[75]})
@

This illustrates that the between-node prevalence increases for
increasing values of the transmission rate $\beta$, but decreases for
increasing values of the recovery rate $\gamma$
(Figure~\ref{fig:SIR-run-outer}).  The relationship is more complex
for the population prevalence.

\begin{figure}[htb]
  \begin{center}
<<SIR-run-outer-plot, fig=TRUE, echo=FALSE>>=
opar <- par(mfrow = c(1, 2), oma = c(1, 1, 3, 0), mar = c(4, 3, 1, 1))
contour(x * model@gdata["beta"], y * model@gdata["gamma"],
        pop, method = "edge", bty = "l")
title("Population prevalence")
mtext(expression(beta), side = 1, line = 3)
mtext(expression(gamma), side = 2, line = 2)
contour(x * model@gdata["beta"], y * model@gdata["gamma"],
bnp, method = "edge", bty = "l")
title("Between-node prevalence")
mtext(expression(beta), side = 1, line = 3)
mtext(expression(gamma), side = 2, line = 2)
par(opar)
@
  \end{center}
  \caption{Contour plot of the population- and between-node prevalence
    after simulating 75 days of an \code{SIR} model in 500 nodes,
    starting with 99 susceptible, 1 infected, and 0 recovered
    individuals in each node at the first
    day. \label{fig:SIR-run-outer}}
\end{figure}

\subsubsection[Specification of scheduled events in the SIR model]{Specification of scheduled events in the \code{SIR} model}

In this example, we will continue to work with the built-in \code{SIR}
model to explore a within node disease spread similar to the first SIR
example but with the additional feature that individuals enter and
exit the simulation and that disease can spread between nodes via
movements of infected individuals between nodes.

We will start with the inclusion of a set of individuals that are
moved between nodes in the network (\textit{external transfer}
events). These events are predefined prior to the simulation and are
applied during the simulation process. For example, if your simulation
time is in days, then after each day, SimInf will apply the events in
the data and move individuals between nodes.  In the following example
we have five nodes with movements between nodes. To illustrate the
movements themselves, we have only started with 30 individuals in the
first node and the other four are empty, and we will run the
simulation for five timesteps:

<<SIR-u0-multiple-nodes>>=
u0 <- data.frame(S = c(10, 0, 0, 0, 0), I = c(10, 0, 0, 0, 0),
R = c(10, 0, 0, 0, 0))
@

Now we will define 6 scheduled events to include in the simulation.
Below is a \code{data.frame}, that contains the events.  Interpret it
as follows:

\begin{enumerate}
\item In time step 2 we add 2 susceptible individuals to node 2
\item In time step 3 we move 2 individuals from node 1 to node 3
\item In time step 4 we remove 1 individual from node 2
\item In time step 4 we move 1 individual from node 1 to node 3
\item In time step 4 we move 1 individual from node 1 to node 4
\item In time step 5 we move 2 individuals from node 1 to node 5
\end{enumerate}

<<SIR-events, echo=FALSE>>=
events <- structure(list(
    event      = c(1, 3, 0, 3, 3, 3),
    time       = c(2, 3, 4, 4, 4, 5),
    node       = c(2, 1, 2, 1, 1, 1),
    dest       = c(0, 3, 0, 3, 4, 5),
    n          = c(2, 1, 1, 1, 1, 2),
    proportion = c(0, 0, 0, 0, 0, 0),
    select     = c(1, 2, 2, 2, 2, 2),
    shift      = c(0, 0, 0, 0, 0, 0)),
    .Names = c("event", "time", "node", "dest", "n",
               "proportion", "select", "shift"),
    row.names = c(NA, -6L), class = "data.frame")
@

<<SIR-events-show>>=
events
@

Now we are ready to run the simulation using the events and the
disease spread model as we did in earlier examples:

<<U-model-events>>=
model <- SIR(u0, 1:5, events = events, beta = 0.16, gamma = 0.077)
U(run(model, threads = 1, seed = 2))
@

If you inspect the result of this very simple simulation, you will see
that 2 individuals were added to node 2, of which one individual was
later removed, and that some individuals were removed from node 1 and
placed in nodes 3, 4, and 5.  So far this isn't really
earth-shattering, but if we do this again with a few more individuals
then we can see how disease can spread from an infected node to a
non-infected one. We'll start with 5 nodes again, but node 1 is
infected and nodes 2--5 now each have 100 susceptibles and the
simulation will run for 75 days:

<<SIR-u0-multiple-nodes-II>>=
u0 <- data.frame(S = c(90, 100, 100, 100, 100), I = c(10, 0, 0, 0, 0),
R = c(0, 0, 0, 0, 0))
@

And then we have a few movements of individuals from node 1 to the others:

<<SIR-events-II, echo=FALSE>>=
events <- structure(list(
    event      = c(3, 3, 3, 3),
    time       = c(3, 25, 5, 10),
    node       = c(1, 1, 1, 1),
    dest       = c(3, 2, 3, 3),
    n          = c(1, 9, 1, 5),
    proportion = c(0, 0, 0, 0),
    select     = c(2, 2, 2, 2),
    shift      = c(0, 0, 0, 0)),
                    .Names = c("event", "time", "node", "dest",
                        "n", "proportion", "select", "shift"),
    row.names = c(NA, -4L), class = "data.frame")
@

<<SIR-events-II-show>>=
events
@

Initialise and run the model

<<SIR-events-II-run>>=
model <- SIR(u0, 1:75, events = events, beta = 0.16, gamma = 0.077)
result <- run(model, threads = 1, seed = 1)
@

And then plot the result of the model
(Figure~\ref{fig:SIR-spaghetti}).  Note the time that it takes for
node 2 to become positive relative to the movements.  On day 25, 10
individuals are moved to the node causing the outbreak.  Also despite
the fact that we moved inividuals from node 1 to node 3, there was no
outbreak in node 3.  This is because of the random selection process
that select susceptible, infected or recovered individuals to move
between the nodes.

<<SIR-spaghetti, eval=FALSE>>=
plot(result, N = TRUE, spaghetti = TRUE, compartments = "I")
@

\begin{figure}[htb]
  \begin{center}
<<SIR-spaghetti-plot, echo=FALSE, fig=TRUE>>=
plot(result, N = TRUE, spaghetti = TRUE, compartments = "I")
@
  \end{center}
  \caption{The number of infected individuals in each node when
    simulating 75 days of an \code{SIR} model in 5 nodes, starting
    with 90 susceptible and 10 infected individuals in node 1 and 100
    suceptible individuals in nodes 2--5, and moving individuals from
    node 1 to nodes 2 and 3. \label{fig:SIR-spaghetti}}
\end{figure}

\subsubsection[C code for the SIR model]{\proglang{C} code for the \code{SIR} model}

The \proglang{C} code for the \code{SIR} model is defined in the
source file \texttt{'src/models/SIR.c'}.  This file contains the
\code{SIR_run} function to initialize the core solver
(Listing~\ref{lst:SIRrun} in the appendix), the transition rate
functions (Listing~\ref{lst:trSIR} in the appendix) and the post time
step function (Listing~\ref{lst:ptsSIR} in the appendix).

\subsection[A second example: The SISe3_sp model]{A second example: The \code{SISe3\_sp} model}
\label{sec:example-SISe3_sp}

This section illustrates the specification of the \code{SISe3\_sp}
model, which is also built into the \pkg{SimInf} package.  In this
example we will demonstrate two additional features compared to the
\code{SIR} model: ageing of individuals by \textit{internal transfer}
events, and the real valued continuous state $V$.  The
\code{SISe3\_sp} model contains the two compartments susceptible
(\code{S}) and infected (\code{I}) divided into the three age
categories $j = \{1, 2, 3\}$ and the local environmental compartment
(\code{e}) contaminated with free living pathogens
(Figure~\ref{fig:SISe3_sp}).  Moreover, nodes are spatially connected
with local spread of the contaminated environmental compartment among
proximal nodes.  The transmission route of infection to susceptible
individuals is indirect via the local environment, contaminated by
infected individuals.  The number of individuals in each of the six
compartments $\{S_1, I_1, S_2, I_2, S_3, I_3\}$ in node $i$ at time
$t$ is \mbox{\code{u[, i]}}.  The \code{SISe3\_sp} model has two state
transitions within each of the three age categories,
\begin{align}
\label{eq:vtectrans}
\begin{array}{rcl}
  S_{ij} & \xrightarrow{\upsilon_j \varphi_i} & I_{ij}, \\
  I_{ij} & \xrightarrow{\gamma_j} & S_{ij},
  \end{array}
\end{align}

where the state transition from susceptible to infected depends on the
concentration of the environmental contamination $\varphi_i(t)$ of the
pathogen in node $i$ and the indirect transmission rate $\upsilon_j$.
The state transition from infected to susceptible depends on the
recovery rate $\gamma_j$.  Finally, the environmental infectious
pressure is evolved by
\begin{equation}
  \label{eq:envInfPressure-local-spread}
  \frac{d \varphi_i(t)}{dt}= \frac{\alpha I_i(t)}{N_i(t)} +
  \sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
    \cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t),
\end{equation}

where the constant $\alpha$ is the average shedding rate of the
pathogen to the environment per infected individual, and $N_i = S_i +
I_i$ the size of node $i$.  The decay and removal of the pathogen is
captured by $\beta$, which is allowed to vary with time.  The model
also includes a spatial component with local spread among proximal
nodes.  Let $D$ be the rate of the local spread and $d_{ik}$ the
distance between the two holdings $i$ and $k$.  When running a
trajectory of the \code{SISe3\_sp} model the value of the
environmental infectious pressure $\varphi_i(t)$ in each node is saved
to the \code{V} matrix at the time-points specified by \code{tspan}.

\begin{figure}
  \begin{center}
    \includegraphics[width=0.70\linewidth]{img/SISe3_sp.pdf}
  \end{center}
  \caption{Schematic representation of the \code{SISe3\_sp}
    compartment model in two nodes.  The \code{SISe3\_sp} model is
    defined by the two disease states susceptible (S) and infected (I)
    in three age categories and indirect transmission via an
    environmental infectious pressure $\varphi_i$.  \textit{i)} State
    transitions between the $S$ and $I$ compartments are modeled as a
    continuous-time discrete-state Markov process.  The other state
    transitions are due to scheduled events: \textit{ii)}
    \textit{enter} events, \textit{iii)} \textit{internal transfer}
    events, \textit{iv)} \textit{external transfer} events, and
    \textit{v)} \textit{exit} events.  The environmental infectious
    pressure $\varphi_i$ is modelled with an ordinary differential
    equation and by default evolved by the Euler forward
    method.  \label{fig:SISe3_sp}}
\end{figure}

To illustrate the stochastic step, Equation~\ref{eq:numstep3},
consider that the number of individuals in each compartment in node
$i$ \code{u[, i]} at time $t$ is $\{12, 3, 63, 14, 92, 2\}$ and that
the time to the next state transition is $\tau_i$.  Furthermore,
assume that the next state transition is infected to susceptible in
the first age category.  This corresponds to the second column in the
state change matrix \code{S}.  Thus, updating the compartments
corresponds to adding \code{S[, 2]} to \code{u[, i]}, which gives
$\{13, 2, 63, 14, 92, 2\}$.  This also implies that the transition
rates for the two transitions $S_{i,1} \rightarrow I_{i,1}$ and
$I_{i,1} \rightarrow S_{i,1}$ must be recalculated according to
\code{G[, 2]}.

{\small
\[
\mathbf{S} =
\begin{blockarray}{crrrrrr}
  & 1 & 2 & 3 & 4 & 5 & 6 \\
  \begin{block}{c(rrrrrr)}
    S_1 & -1 &  1 &  0 &  0 &  0 &  0 \\
    I_1 &  1 & -1 &  0 &  0 &  0 &  0 \\
    S_2 &  0 &  0 & -1 &  1 &  0 &  0 \\
    I_2 &  0 &  0 &  1 & -1 &  0 &  0 \\
    S_3 &  0 &  0 &  0 &  0 & -1 &  1 \\
    I_3 &  0 &  0 &  0 &  0 &  1 & -1 \\
  \end{block}
\end{blockarray} \qquad
\mathbf{G} =
\begin{blockarray}{ccccccc}
  & 1 & 2 & 3 & 4 & 5 & 6 \\
  \begin{block}{c(rrrrrr)}
    S_1 \rightarrow I_1 & 1 & 1 & 0 & 0 & 0 & 0 \\
    I_1 \rightarrow S_1 & 1 & 1 & 0 & 0 & 0 & 0 \\
    S_2 \rightarrow I_2 & 0 & 0 & 1 & 1 & 0 & 0 \\
    I_2 \rightarrow S_2 & 0 & 0 & 1 & 1 & 0 & 0 \\
    S_3 \rightarrow I_3 & 0 & 0 & 0 & 0 & 1 & 1 \\
    I_3 \rightarrow S_3 & 0 & 0 & 0 & 0 & 1 & 1 \\
  \end{block}
\end{blockarray}
\]
}

\subsubsection[Specification of scheduled events in the SISe3_sp model]{Specification of scheduled events in the \code{SISe3\_sp} model}

The select matrix \code{E} and the shift matrix \code{N} in the
\code{SISe3\_sp} model are specified to handle births, imports,
ageing, moving and exits of individuals
(Table~\ref{table:SISe3_sp:events}).  When individuals enter the model
(births, imports), they are added to the susceptible state of a age
category, where the age category is specified by column 1, 2 or 3 in
\code{E}.  The columns 4, 5 and 6 in \code{E} are used for the other
events (ageing, moving, exit) to sample individuals from the
susceptible and infected states from each of the three ages catgories.
To move the sampled individuals in a \textit{internal transfer} event
(ageing) from age category 1 to age category 2, the susceptible and
infected states should shift two steps to the corresponding state in
age category 2, as specified in \code{N[, 1]} In the same way,
\code{N[, 2]} move susceptible and infected individuals in age
category 2 to age category 3.

{\small
\[
\mathbf{E} =
\begin{blockarray}{crrrrrr}
  & 1 & 2 & 3 & 4 & 5 & 6 \\
  \begin{block}{c(rrrrrr)}
    S_1 & 1 & 0 & 0 & 1 & 0 & 0 \\
    I_1 & 0 & 1 & 0 & 1 & 0 & 0 \\
    S_2 & 0 & 0 & 1 & 0 & 1 & 0 \\
    I_2 & 0 & 0 & 0 & 0 & 1 & 0 \\
    S_3 & 0 & 0 & 0 & 0 & 0 & 1 \\
    I_3 & 0 & 0 & 0 & 0 & 0 & 1 \\
  \end{block}
\end{blockarray} \qquad
\mathbf{N} =
\begin{blockarray}{ccc}
  & 1 & 2 \\
  \begin{block}{c(rr)}
    S_1 & 2 & 0 \\
    I_1 & 2 & 0 \\
    S_2 & 0 & 2 \\
    I_2 & 0 & 2 \\
    S_3 & 0 & 0 \\
    I_3 & 0 & 0 \\
  \end{block}
\end{blockarray}
\]
}

\subsection[C code for the SISe3_sp model]{\proglang{C} code for the \code{SISe3\_sp} model}

The \proglang{C} code for the \code{SISe3\_sp} model is defined in the
source file \texttt{'src/models/SISe3\_sp.c'}.  This file contains the
\code{SISe3\_sp\_run} function to initialize the core solver
(Listing~\ref{lst:SISe3_sp_run} in the appendix), the transition rate
functions (Listing~\ref{lst:trSISe3_sp} in the appendix) and the post
time step function to update the local environmental infectious
pressure $\varphi$ (Listing~\ref{lst:ptsSISe3_sp} in the appendix).

%% \begin{figure}
%%   \begin{center}
%%     \includegraphics[width=0.8\linewidth]{img/events_SISe3.pdf}
%%   \end{center}
%%   \caption{The distribution of the synthetic scheduled events dataset
%%     \code{events\_SISe3}, that is ditributed with the \pkg{SimInf}
%%     package.  The \textit{enter} event, adds individuals to a node.
%%     The \textit{internal transfer} event, changes the number of
%%     individuals in the compartments within one node.  The
%%     \textit{external transfer} event, moves individuals from
%%     compartments in one node to compartments in a destination node.
%%     Finally, the \textit{exit} event removes individuals from a node.}
%%   \label{fig:events_SISe3_sp}
%% \end{figure}

%**************************************************************************

\clearpage

\section[Extending SimInf: New models]{Extending \pkg{SimInf}: New models}
\label{sec:extend}

One of the design goals of \pkg{SimInf} was to make it extendable.
The current design supports two ways to extend \pkg{SimInf} with new
models, and this section desribes the relevant steps to implement a
new model.  Since extending \pkg{SimInf} requires that \proglang{C}
code can be compiled, you will first need to install a compiler.

\subsection{Using the model parser to define a new model}
\label{sec:mparse}

The easiest way to define a new model for \pkg{SimInf} is to use the
built-in model parser method \code{mparse}.  It takes a character
vector of transitions in the form of \code{"X -> propensity -> Y"} and
generates both \proglang{C} code for the model and the two matrices
\code{S} and \code{G}.  The left hand side of the first
'\code{->}'-sign is the initial state, the right hand side of the last
'\code{->}'-sign is the final state, and the propensity is written
between the '\code{->}'-signs.  The special symbol '\code{@}' is
reserved for the empty set $\emptyset$.  We suggest to first draw a
schematic representation of the model that includes all compartments
and arrows for all state transitions.  Then list the compartments in
the order they should appear in the \code{U} matrix.  For example,
\code{transitions <- c("S -> b*S*I/(S+I+R) -> I", "I -> g*I -> R")}
expresses an SIR model in a closed population, where \code{b} is the
transmission rate, and \code{g} is the recovery rate.  We also need to
specify the compartments that defines the model.

<<SIR-mparse-I>>=
transitions <- c("S -> b*S*I/(S+I+R) -> I", "I -> g*I -> R")
compartments <- c("S", "I", "R")
@

We can now use the \code{transitions} and \code{compartments}
variables, together with constants \code{b} and \code{g} to build an
object of class \code{'SimInf\_mparse'} via a call to \code{mparse}.
Before we can simulate from the model, it needs to be initialised with
the initial condition \code{u0} and \code{tspan}.

<<SIR-mparse-II>>=
m <- mparse(transitions, compartments, b = 0.16, g = 0.077)
model <- init(m, u0 = cbind(S = 99, I = 1, R = 0), tspan = 1:180)
@

As in earlier examples, the \code{model} object can now be used to
simulate data and plot the results.  Internally, the \proglang{C} code
that was generated by \code{mparse} is written to a temporary file
when the \code{run} method is called.  If the temporary file is
compiled successfully, the resulting DLL is dynamically loaded and
used to run one trajectory of the model.  Once the simulator
completes, the DLL is unloaded and the temporary files are removed.

<<SIR-mparse-III, eval=FALSE>>=
result <- run(model, threads = 1, seed = 123)
plot(result)
@

\begin{figure}[htb]
  \begin{center}
<<SIR-mparse-IV, echo=FALSE, fig=TRUE>>=
result <- run(model, threads = 1, seed = 123)
plot(result)
@
  \caption{Example of simulated data from one realisation of the
    \code{mparse} \code{SIR} model (Equation~\ref{eq:SIR}) in one
    node, starting with 99 susceptible, 1 infected, and 0 recovered
    individuals. \label{fig:SIR-mparse-proportion}}
  \end{center}
\end{figure}

The flexibility of the \code{mparse} approach allows for quick
prototyping of new models or features.  Let us elaborate on the
previous example and explore the incidence cases per day.  This can
easily be done by adding one compartment \code{'Icum'} whose sole
purpose is to keep track of how many individuals who become infected
over time.  We then calculate successive differences at each
time-point in \code{'Icum'} and plot the result as an epidemic curve
(Figure~\ref{fig:SIR-mparse-incidence}).

<<SIR-mparse-incidence, eval=FALSE>>=
m <- mparse(c("S -> b*S*I/(S+I+R) -> I + Icum", "I -> g*I -> R"),
c("S", "I", "Icum", "R"), b = 0.16, g = 0.077)
model <- init(m, cbind(S = 99, I = 1, Icum = 0, R = 0), 1:180)
result <- run(model, threads = 1, seed = 123)
plot(stepfun(result@tspan[-1], diff(c(0, U(result)["Icum",]))),
main = "", xlab = "Time [days]", ylab = "Number of cases",
do.points = FALSE)
@

\begin{figure}[htb]
  \begin{center}
<<SIR-mparse-incidence-plot, echo=FALSE, fig=TRUE>>=
m <- mparse(c("S -> b*S*I/(S+I+R) -> I + Icum", "I -> g*I -> R"),
c("S", "I", "Icum", "R"), b = 0.16, g = 0.077)
model <- init(m, cbind(S = 99, I = 1, Icum = 0, R = 0), 1:180)
result <- run(model, threads = 1, seed = 123)
plot(stepfun(result@tspan[-1], diff(c(0, U(result)["Icum",]))),
main = "", xlab = "Time [days]", ylab = "Number of cases",
do.points = FALSE)
@
  \end{center}
  \caption{Epidemic curve displaying the number of incident cases in a
    node when simulating 180 days of the \code{mparse} \code{SIR}
    model (Equation~\ref{eq:SIR}), starting with 99 susceptible, 1
    infected and 0 recovered
    individuals.  \label{fig:SIR-mparse-incidence}}
\end{figure}

%**************************************************************************

\section{Acknowledgements}

This work was financially supported by the Swedish Research Council
within the UPMARC Linnaeus centre of Excellence (P.~Bauer,
S.~Engblom), The Swedish Research Council Formas (S.~Engblom,
S.~Widgren), The Swedish Board of Agriculture (S.~Widgren), and by the
Swedish strategic research program eSSENCE (S.~Widgren).

\bibliography{SimInf}

\clearpage

\section{Appendix}

\begin{algorithm}
  \caption{Pseudo-code for the core simulation solver}
  \label{alg:core}
  {\fontsize{10}{10}\selectfont
  \begin{algorithmic}[1]
    \STATE{\textit{Run trajectory:} Dispatch to model specific
      \code{run} method.}

    \STATE{\textit{\proglang{C} interface:} Initialize model
      transition rate functions and post time step function.}

    \renewcommand{\algorithmicdo}{\textbf{do in parallel}}
    \FORALL{nodes i=1 \TO $N_n$}

    \STATE{Compute transition rates for all transitions
      $\omega_{i,j}$, $j=1, \ldots ,N_t$.}

    \STATE{Compute sum of transition rates $\lambda_i =
      \sum_{j=1}^{N_t}\omega_{i,j}$ }

    \STATE{Sample time to next stochastic event $t_i =
      -log(\mbox{rand})/ \lambda_i$} where \textit{rand} is a
    uniformly distributed random number in the range (0, 1)

    \ENDFOR

    \renewcommand{\algorithmicdo}{\textbf{do}}
    \WHILE{$t < T_{\text{End}}$}

    \renewcommand{\algorithmicdo}{\textbf{do in parallel}}
    \FORALL{nodes i=1 \TO $N_n$}

    \renewcommand{\algorithmicdo}{\textbf{do}}
    \WHILE{$t_i < T_{\text{Next day}}$}

    \STATE{Determine which state transition happened; by inversion,
      find $n$ such that \\$\sum_{j=1}^{n-1} \omega_{i,j} < \lambda \,
      \mbox{rand} \le \sum_{j=1}^n \omega_{i,j}$} where \textit{rand}
    is a uniformly distributed random number in the range (0, 1)

    \STATE{Update the compartments \code{u[, i]} using the
      state-change vector \code{S[, n]}}

    \STATE{Use the dependency graph \code{G[, n]} to recalculate
      affected transition rates $\omega_{i,j}$}

    \STATE{Compute sum of transition rates $\lambda_i =
      \sum_{j=1}^{N_t}\omega_{i,j}$ }

    \STATE{Sample time to next stochastic event $\tau_i =
      -log(\text{\mbox{rand}})/ \lambda_i$} where \textit{rand} is a
    uniformly distributed random number in the range (0, 1)

    \STATE{Move simulated time forward $t_i = t_i + \tau_i$}

    \ENDWHILE

    \STATE{Process $E_1$ events}

    \ENDFOR

    \STATE{Process $E_2$ events}

    \FORALL{nodes i=1 \TO $N_n$}

    \STATE{Call post time step function and update the continuous
      state variable \code{v[ ,i]}.}

    \ENDFOR

    \STATE{$T_{\text{Next day}} = T_{\text{Next day}} + 1$}

    \ENDWHILE
  \end{algorithmic}}
\end{algorithm}

\clearpage

\begin{minipage}{\linewidth}
\begin{scriptsize}
  \begin{lstlisting}[
      language=C, caption={Implementation of the function to init and
        run a simulation with the \code{SIR} model},
      label={lst:SIRrun}, frame=single]
  SEXP SIR_run(SEXP model, SEXP threads, SEXP seed)
  {
      TRFun tr_fun[] = {&SIR_S_to_I, &SIR_I_to_S};

      return SimInf_run(model, threads, seed, tr_fun, &SISe3_post_time_step);
  }
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[
    language=C, caption={Implementation of the transition rate
      functions in the \code{SIR} model for the transitions in
      Equation~\ref{eq:SIR} between the susceptible and infected
      compartments.  The enumeration declarations are used to name the
      variable offsets and facilitate extraction of the values from
      the various data vectors.}, label={lst:trSIR} , frame=single]

  /* Offset in integer compartment state vector */
  enum {S, I, R};

  /* Offsets in global data (gdata) to parameters in the model */
  enum {BETA, GAMMA};

  /* susceptible to infected: S -> I */
  double SIR_S_to_I(const int *u, const double *v, const double *ldata,
                    const double *gdata, double t)
  {
      const double S_n = u[S];
      const double I_n = u[I];
      const double n = S_n + I_n + u[R];

      if (n > 0.0)
          return (gdata[BETA] * S_n * I_n) / n;
      return 0.0;
  }

  /* infected to susceptible: I -> S */
  double SIR_I_to_S(const int *u, const double *v, const double *ldata,
                    const double *gdata, double t)
  {
      return gdata[GAMMA] * u[I];
  }
\end{lstlisting}

\begin{lstlisting}[
      language=C, caption={Implementation of the post time step
        function in the \code{SIR} model.  The function returns a
        value $>0$ if the node needs to recalculate the transition
        rates else $0$.  However, if an error is detected the function
        returns an error code $<0$.}, label={lst:ptsSIR}
      ,frame=single]

  int SIR_post_time_step(double *v_new, const int *u, const double *v,
                         const double *ldata, const double *gdata,
                         int node, double t)
  {
      return 0;
  }
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\clearpage

\end{document}
