%% -*- mode: LaTeX; coding: utf-8; -*-
\documentclass[nojss]{jss}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{tabularx}

%% Macros for the 'Epidemiological modeling' section
\newcommand{\Connect}{\mathbb{C}}
\newcommand{\fatmu}{\boldsymbol{\mu}}
\newcommand{\fatnu}{\boldsymbol{\nu}}
\newcommand{\Intdom}{\mathbf{Z}}
\newcommand{\Ncompartments}{N_{\mbox{{\tiny comp}}}}
\newcommand{\Nconcentrations}{N_{\mbox{{\tiny conc}}}}
\newcommand{\Ntransitions}{N_{\mbox{{\tiny trans}}}}
\newcommand{\Nnodes}{N_{\mbox{{\tiny nodes}}}}
\newcommand{\Realdom}{\mathbf{R}}
\newcommand{\Stoich}{\mathbb{S}}
\newcommand{\X}{\mathbb{X}}
\newcommand{\Y}{\mathbb{Y}}

% *** use this command to write comments; it is easy to spot in the text!
\newcommand{\comment}[1]{\textcolor{blue}{\{#1\}}}
\newcommand{\margincomment}[1]{{\textcolor{blue}*} \marginpar{\textcolor{blue}{*\{#1\}}}}

\author{Stefan Widgren\\National Veterinary Institute\\
  and Uppsala University\\Sweden\And
  Pavol Bauer\\Uppsala University\\Sweden\And
  Stefan Engblom\\Uppsala University\\Sweden}

\Plainauthor{Stefan Widgren, Pavol Bauer, Stefan Engblom}

\title{\pkg{SimInf}: An \proglang{R} package for Data-driven
  Stochastic Disease Spread Simulations}

\Plaintitle{SimInf: An R package for Data-Driven Stochastic Disease
  Spread Simulations}

\Shorttitle{\pkg{SimInf}: Data-driven Stochastic Disease Spread
  Simulations}

\Abstract{

  Livestock movements are critical for the spread of many infectious
  diseases in animal populations.  The use of real livestock data
  allows for disease spread modeling that incorporates the
  time-varying contact network and the population demographic.  This
  paper introduces \pkg{SimInf}, an efficient and general framework
  for stochastic spatio-temporal disease-spread modeling over a
  temporal network of connected nodes.  It integrates within-node
  infection dynamics as continuous-time Markov chains and livestock
  data as scheduled events.  The core simulation solver is implemented
  in \proglang{C} and uses \proglang{OpenMP} to divide work over
  multiple processors.  We provide a technical description of the
  framework, how to use a predefined model in \pkg{SimInf},
  demonstrate a case study, and finally show how to extend the
  framework with a user defined model.

}

\Keywords{computational epidemiology, discrete-event simulation,
  multicore implementation, stochastic modeling}
\Plainkeywords{computational epidemiology, discrete-event simulation,
  multicore implementation, stochastic modeling}

\Address{
  Stefan Widgren\\
  Department of Disease Control and Epidemiology\\
  National Veterinary Institute\\
  SE-751 89 Uppsala, Sweden\\
  E-mail: \email{stefan.widgren@sva.se}\\
  \textit{and}\\
  Division of Scientific Computing\\
  Department of Information Technology\\
  Uppsala University\\
  SE-751 05 Uppsala, Sweden\\
  E-mail: \email{stefan.widgren@it.uu.se}\\
  \\
  Pavol Bauer\\
  Division of Scientific Computing\\
  Department of Information Technology\\
  Uppsala University\\
  SE-751 05 Uppsala, Sweden\\
  E-mail: \email{pavol.bauer@it.uu.se}\\
  \\
  Stefan Engblom\\
  Division of Scientific Computing\\
  Department of Information Technology\\
  Uppsala University\\
  SE-751 05 Uppsala, Sweden\\
  E-mail: \email{stefane@it.uu.se}
}

<<echo=false, results=hide>>=
options(prompt = "R> ", continue = "+    ", width = 74, useFancyQuotes = FALSE)
@

\begin{document}

\SweaveOpts{engine=R,eps=FALSE,height=5,width=10}
%\VignetteIndexEntry{SimInf: An R package for Data-Driven Stochastic Disease Spread Simulations}
%\VignetteDepends{SimInf}
%\VignetteKeywords{computational epidemiology, discrete-event simulation, multicore implementation, stochastic modeling}
%\VignettePackage{SimInf}

%**************************************************************************

\section{Introduction}

Livestock movements are an important transmission route for many
infectious diseases and can transfer infectious individuals between
holdings over large distances \citep{Danon2011}.  The livestock
movements between holdings can be represented as a temporal network
with nodes coupled by directed edges and the time when each edge was
active \citep{Holme2012}.  The temporal network of livestock movements
forms a complex dynamic system in the topology, connectivity and
intensity \citep{Bajardi2011, Dutta2014}, and these properties affect
how various diseases spread in a network \citep{Shirley2005,
  Buettner2014}.  European Union legislation requires member states to
keep a registry of all bovine animals in national databases
\citep{EC-No-1760-2000, EC-No-911-2004}, which makes it possible to
use real data for the time-varying contact network and the population
demographics for large scale disease spread simulations, to better
understand transmission and explore control strategies.  However,
incorporating large amount of network data in simulations is
computationally challenging and require efficient algorithms.
Furthermore, specifying realistic models for disease transmission is a
complicated process since various diseases have fundamentally
different transmission routes. Compare, for example, fecal-oral
pathogens with indirect transmission routes via the environment with
infections that are transferred by direct contact between individuals
\citep{BrooksPollock2014}.

In this work, we present an efficient and flexible framework for
data-driven spatio-temporal disease spread modeling, designed to
efficiently incorporate large volumes of population demographics and
temporal network data.  This allows the user to asses the spread of,
for example, endemic diseases in the cattle population, in national
scale simulations \citep{Bauer2016}.  We have developed the
\proglang{R} \citep{R} package \pkg{SimInf}, a discrete-event
simulator that divides work among multiple processors available in
standard computers.  The model integrates infection dynamics as
continuous-time Markov chains (CTMC) and available data such as animal
movements, births, slaughter or aging are incorporated as scheduled
events.  One of our design goal was to make \pkg{SimInf} completely
extendable and allow for growth in available models and specialized
solvers through contributions from the community.  Using compiled
\proglang{C} code, rather than interpreted \proglang{R} code, for the
transition-rate functions ensures maximum efficiency when simulating
the model.  To simplify the process of generating the required
\proglang{C} code for models, the \pkg{SimInf} package include
functionality to automatically create \proglang{C} code from a model
specification.

There exists several related \proglang{R} packages for epidemiological
modeling on the Comprehensive \proglang{R} Archive Network (CRAN) that
we would like to mention here.  The package \pkg{amei} \citep{amei} is
designed for parameter estimation of epidemic models and finding
optimal intervention strategies, for example, vaccination, to control
disease spread.  Another package is \pkg{surveillance}, a framework
for monitoring, modeling, and regression analysis of infectious
diseases, \citep{surveillance}.  \pkg{EpiModel} \citep{EpiModel} is an
\proglang{R} package that, similar to \pkg{SimInf}, includes a
framework for modeling spread of diseases on networks.  However, they
differ in how the data is generated for the modeling: the network data
in \pkg{EpiModel} is simulated using \pkg{statnet} \citep{statnet},
while \pkg{SimInf} was designed to incorporate available network data.
The are also similarities between the \proglang{R} package
\pkg{GillespieSSA} \citep{Pineda-Krch2008} and \pkg{SimInf}, in that
both uses the Gillespie stochastic simulation algorithm (SSA)
\citep{Gillespie1977}.  However, for computational efficiency, the
algorithm is implemented using \proglang{C} code in \pkg{SimInf}.

The paper is organized as follows.  In \S\ref{sec:modeling} we
summarize the mathematical foundation for our framework.  Section
\S\ref{sec:framework} gives a technical description of the simulation
framework.  In \S\ref{sec:examples} we illustrate the use of the
package by some worked examples.  Finally, in \S\ref{sec:extend} we
demonstrate how to extend \pkg{SimInf} with user-defined models.

%**************************************************************************

\section{Epidemiological modeling}
\label{sec:modeling}

In the following section we give a brief overview of the
epidemiological modeling framework employed in \pkg{SimInf}. The
overall approach consists of continuous-time Markov chains as a
general model of the dynamics of the epidemiological
state. Importantly, we also allow for a coupling with concentration
variables obeying ordinary differential equations (ODEs), as well as
to externally defined events. We draw much of the material here from
\citep{Bauer2016, siminf_Ch}.

In \S\ref{subsec:local}--\ref{subsec:global} below we distinguish
between the \emph{local} dynamics that describes the evolution of the
epidemiological state at a single node, and the \emph{global}
dynamics, which describes the system at the network level. The overall
numerical approach underlying \pkg{SimInf} is described in
\S\ref{subsec:numerics}.

\begin{figure}
    \begin{subfigure}[b]{0.85\textwidth}
      \begin{center}
        \includegraphics{img/temporal-network.pdf}
        \caption{Snapshots}
      \end{center}
    \end{subfigure}
    \hspace{-10mm}
    \begin{subfigure}[b]{0.14\textwidth}
      \begin{center}
        $(3, 2, 1, 9)$\\
        $(3, 4, 1, 2)$\\
        $(1, 3, 2, 8)$\\
        $(4, 3, 2, 3)$\\
        $(3, 2, 3, 5)$\\
        $(4, 2, 3, 4)$\\
        \vspace{9mm}
        \caption{Events}
      \end{center}
    \end{subfigure}
  \caption{Illustration of livestock movements as a temporal network.
    (a) Each snapshot depicts movements during one time unit, for
    example, a day.  The network has $N = 4$ nodes where node $1$ is
    infected and $2$--$4$ are non-infected nodes.  Arrows indicate
    animal movements from a source node to a destination node, where
    labels denote the size of the shipment.  In this example,
    infection may spread by livestock movements from $1$ to $3$ at
    $t=2$ (indicated by blue lines in node $3$ at $t=3$) and then from
    $3$ to $2$ at $t=3$.  (b) The livestock movements represented as
    events where each event contains $(\mathit{source},
    \mathit{destination}, t, n)$.
    \label{fig:temporal-network}}
\end{figure}

\subsection{Local dynamics}
\label{subsec:local}

We describe the state of a single node with a \emph{state vector}
$X(t) \in \Intdom_{+}^{\Ncompartments}$, which counts the number of
individuals at each of $\Ncompartments$ compartments at time $t$. The
transitions between these compartments are stochastic and are
described by the transition matrix $\Stoich \in
\Intdom^{\Ncompartments \times \Ntransitions}$ and the transition
intensities $R: \Intdom_{+}^{\Ncompartments} \to
\Realdom_{+}^{\Ntransitions}$, assuming $\Ntransitions$ different
transitions. We then form a \textit{random counting measure}
$\mu_{k}(dt) = \mu(R_{k}(X(t-)); \, dt)$ that is associated with a
Poisson process for the $k$th intensity $R_{k}(X(t-)$, which in turn
depends on the state prior to any transition at time $t$, that is,
$X(t-)$.

The local dynamics can then compactly be described by a pure jump
stochastic differential equation (SDE),
\begin{align}
  \label{eq:vectorJSDE}
  dX(t) &= \Stoich\fatmu(dt),
\end{align}
where $\fatmu(dt)$ is a vector measure built up from the scalar
counting measures $\fatmu(dt) = [\mu_{1}(dt),\ldots,$
  $\mu_{\Ntransitions}(dt)]^\top$. If at time $t$, transition $k$
occurs, then the state vector is updated according to
\begin{align}
  \label{eq:eventupdate}
   X(t)=X(t-)+\Stoich_k,
\end{align}
with $\Stoich_k$ the $k$th column of $\Stoich$. In
\eqref{eq:vectorJSDE} the $\Ntransitions$ different epidemiological
state transitions are competing in the sense of independent Poisson
processes. The `winning' process decides what event happens and
changes the state according to \eqref{eq:eventupdate}. The simulation
then proceeds under the Markov assumption where previous events are
remembered via the state variable $X$ only.

To make this abstract notation a bit more concrete we consider a
traditional example as follows. In an SIS-model the transitions
between a susceptible and an infected compartment can be written as
\begin{align}
\label{eq:sirtrans}
  &\left. \begin{array}{rl}
    S+I &\xrightarrow{\beta} 2I \\
    I &\xrightarrow{\gamma} S \\
  \end{array} \right\}.
  \intertext{With a state vector consisting of two compartments $X =
    [\#S,\#I]$, i.e., the number of susceptible and infected
    individuals, respectively, we can then write the transition matrix
    and intensity vector as}
  \label{eq:SIRstoich}
    \Stoich &= \left[ \begin{array}{rr}
        -1 & 1 \\
        1  & -1
      \end{array} \right], \\
    R(x) &= [\beta x_{1}x_{2},\gamma x_{2}]^\top.
\end{align}
To connect this with traditional ODE-based models, note that,
replacing the random measure in \eqref{eq:vectorJSDE} with its mean
drift, we arrive at
\begin{align}
  \label{eq:ODE}
  \frac{dx(t)}{dt} &= \Stoich R(x),
\end{align}
where now the state variable $x \in \Realdom^{\Ncompartments}$. The
differences between \eqref{eq:vectorJSDE} and \eqref{eq:ODE} are that
the randomness and discreteness of the state variable are not present
in the latter formulation. If these features are thought to be
important, then \eqref{eq:vectorJSDE} is an accurate stochastic
alternative to \eqref{eq:ODE}, relying only on the Markovian
``memoryless'' assumption.

There are, however, situations where we would like to mix the discrete
stochastic model with a concentration-type ODE model. In a multi-scale
description there are typically variables for which a continuous
description is more natural: a typical example is the concentration of
bacteria in an infectious environment for which individual counting
would clearly not be feasible.

Assuming an additional concentration state vector $Y \in
\Realdom^{\Nconcentrations}$ a general model which augments
\eqref{eq:vectorJSDE} is
\begin{align}
  \label{eq:JSDE_ODE}
  \left. \begin{array}{rcl}
    dX(t) &=& \Stoich\fatmu(dt) \\
    Y'(t) &=& f(X(t-),Y(t)) \\
  \end{array} \right\},
\end{align}
where now the random measure depends also on the concentration
variable,
\begin{align}
  \fatmu(dt) = \fatmu(R(X(t-),Y(t)),dt).
\end{align}
The overall combined state vector is then $[X; \; Y] \in
[\Intdom^{\Ncompartments}; \; \Realdom^{\Nconcentrations}]$.

\subsection{Global dynamics}
\label{subsec:global}

To extend the local dynamics to a network model consisting of
$\Nnodes$ nodes we first define the overall state matrices $\X \in
\Intdom_{+}^{\Ncompartments \times \Nnodes}$ and $\Y \in
\Realdom^{\Nconcentrations \times \Nnodes}$ and then extend
\eqref{eq:JSDE_ODE} to
\begin{align}
  \label{eq:local1}
  d\X^{(i)}(t) &= \Stoich\fatmu^{(i)}(dt), \\
  \label{eq:local2}
  \frac{d\Y^{(i)}(t)}{dt} &= f(\X^{(i)},\Y^{(i)}),
\end{align}
where $i \in \{1,...,\Nnodes\}$ is the node index.

We then consider the $\Nnodes$ nodes being the vertices of an
undirected graph $\mathcal{G}$ with interactions defined in terms of
the counting measures $\fatnu^{(i,j)}$ and $\fatnu^{(j,i)}$. Here
$\fatnu^{(i,j)}$ represents the state changes due to an inflow of
individuals from node $i$ to node $j$, and $\fatnu^{(j,i)}$ represents
an inflow of individuals from node $j$ to node $i$, assuming node $j$
being in the connected component $C(i)$ of node $i$, and vice versa.

The network dynamics is then written as
\begin{align}
  \label{eq:global1}
  d\X^{(i)}_{t} &= -\sum_{j \in C(i)} \Connect\fatnu^{(i,j)}(dt)+
  \sum_{j; \, i \in C(j)} \Connect\fatnu^{(j,i)}(dt), \\
  \label{eq:global2}
  \frac{d\Y^{(i)}(t)}{dt} &= -\sum_{j \in C(i)} g(\X^{(i)},\Y^{(i)})+
  \sum_{j; \, i \in C(j)} g(\X^{(j)},\Y^{(j)}).
\end{align}
In \eqref{eq:global2}, $g$ is similarly the ``flow'' of the
concentration variable $\Y$ between the nodes in the network. For
example, this could be the natural modeling target for concentration
variables $\Y$ which are transported via surface water or air.

Combining this with \eqref{eq:local1}--\eqref{eq:local2} we obtain the
overall dynamics
\begin{align}
  \label{eq:master1}
  d\X^{(i)}(t) &= \Stoich\fatmu^{(i)}(dt)-
  \sum_{j \in C(i)} \Connect\fatnu^{(i,j)}(dt)+
  \sum_{j; \, i \in C(j)} \Connect\fatnu^{(j,i)}(dt), \\
  \label{eq:master2}
  \frac{d\Y^{(i)}(t)}{dt} &= f(\X^{(i)},\Y^{(i)})-
  \sum_{j \in C(i)} g(\X^{(i)},\Y^{(i)})+
  \sum_{j; \, i \in C(j)} g(\X^{(j)},\Y^{(j)}).
\end{align}

Note that $\fatnu^{(i,j)}$ and $\fatnu^{(j,i)}$ may be equivalently
employed for externally scheduled events given by data using an
equivalent construction in terms of Dirac measures. This is the case,
for example, when intra-nodal transport data of individuals are
available.

\subsection{Numerical method}
\label{subsec:numerics}

In \pkg{SimInf}, we solve \eqref{eq:master1}--\eqref{eq:master2} by
splitting the local update scheme \eqref{eq:local1}--\eqref{eq:local2}
from the global update scheme
\eqref{eq:global1}--\eqref{eq:global2}. We discretize time as $0 =
t_{0} < t_{1} < t_2 < \cdots$, which is partially required as external
data has to be incorporated at some finitely resolved time stamps. The
numerical method of \pkg{SimInf} can then be written per node $i$ as
\begin{align}
  \label{eq:numstep1}
  \tilde{\X}_{n+1}^{(i)} &= \X_{n}^{(i)} + \int^{t_{n+1}}_{t_n}
  \Stoich \fatmu^{(i)}(ds), \\
  \label{eq:numstep2}
  \X_{n+1}^{(i)} &= \tilde{\X}^{(i)}_{n+1}-\int^{t_{n+1}}_{t_n} \sum_{j \in C(i)}
  \Connect\fatnu^{(i,j)}(ds)+\int^{t_{n+1}}_{t_n} \sum_{j; \, i \in C(j)}
  \Connect\fatnu^{(j,i)}(ds), \\
  \label{eq:numstep3}
  \Y_{n+1}^{(i)} &= \Y_{n}^{(i)} + f(\tilde{\X}_{n+1}^{(i)},
  \Y_{n}^{(i)}) \, \Delta t_{n} \\
  \nonumber
  &\phantom{=}
  -\sum_{j \in C(i)} g(\tilde{\X}_{n+1}^{(i)},\Y_{n}^{(i)})\Delta t_{n}+
  \sum_{j; \, i \in C(j)} g(\tilde{\X}_{n+1}^{(j)},\Y_{n}^{(j)})\Delta t_{n}.
\end{align}

In this scheme, \eqref{eq:numstep1} forms the local stochastic step,
that is in practice simulated by the Gillespie method
\citep{Gillespie1977}. Equation~\ref{eq:numstep2} is the data step,
where externally scheduled events are incorporated. Note that the
stochastic step evolves at continuous time increments in the interval
$[t_n,t_{n+1}]$, and the data step operates only on the final state
$\tilde{\X}$ at $t_{n+1}$. The final step \eqref{eq:numstep3} is just
the Euler forward method in time with time-step $\Delta t_{n} =
t_{n+1}-t_{n}$ for the concentration variable $\Y$.

%**************************************************************************

\section{Technical description of the simulation framework}
\label{sec:framework}

The overall design of \pkg{SimInf} was inspired and partly adapted
from the Unstructured Mesh Reaction-Diffusion Master Equation (URDME)
framework \citep{Engblom2009, Drawert2012}.  \pkg{SimInf} is a general
software framework for data-driven modeling and simulation of
stochastic disease-spread in a temporal network of connected nodes.
In particular, the transition rates and the transition topology are
specified using a compiled language \proglang{C} and \proglang{R}
matrices, respectively.  The overall modular design makes extensions
easy to handle and since the simulation engine is written in a
compiled language, the efficiency of the simulator is very high.

The most recent stable version of \pkg{SimInf} is distributed via CRAN
(\url{https://CRAN.R-project.org/package=SimInf}) and may, depending
on your platform, be available in source form or compiled binary form.
The development version is available on GitHub
(\url{https://github.com/stewid/SimInf}).  A binary form of
\pkg{SimInf} for macOS or Windows can be installed directly from CRAN.
However, if you install \pkg{SimInf} from source (from CRAN or a
\code{.tar.gz} file), the installation process requires a \proglang{C}
compiler, and that the GNU Scientific Library (GSL)
\citep{Gallassi2009} is installed on your system and is in the path.
Note that GSL (\url{https://www.gnu.org/software/gsl/}) is not an
\proglang{R} add-on package, but needs to be installed separately, for
example, from a terminal using: \code{'sudo apt-get install
  libgsl0-dev'} on Debian and Ubuntu, \code{'sudo yum install
  gsl-devel'} on Fedora, CentOS or RHEL, or \code{'brew install gsl'}
on macOS with the Homebrew package manager.  On a Windows machine you
first need to download and install Rtools from
\url{https://cran.r-project.org/bin/windows/Rtools}.  The GSL files
are downloaded, if needed, from \url{https://github.com/rwinlib/gsl}
during the installation of \pkg{SimInf}.  Furthermore, when you
install \pkg{SimInf} from source, depending on features of the
compiler, the package is compiled with support for \proglang{OpenMP}
\citep{OpenMP2008} to divide work over multiple processors and perform
computations in parallel.  To find out more about installing
\proglang{R} add-on packages in general, the \texttt{'R Installation
  and Administration'} (\url{https://cran.r-project.org/manuals.html})
manual describes the process in detail.  After installing the package

<<install-SimInf, eval=FALSE>>=
install.packages("SimInf")
@

it is loaded in \proglang{R} with the following command

<<load-SimInf>>=
library("SimInf")
@

\subsection{Overview}

The \pkg{SimInf} \proglang{R} package uses object oriented programming
with \code{S4} classes \citep{Chambers2008} to define objects with
logical layers connected by well-defined interfaces for different
modeling scenarios.  The two \code{S4} classes \code{SimInf\_model}
and \code{SimInf\_events} are central and provide the basis for the
flexible framework to perform efficient simulations in compiled
\proglang{C} code of the predefined models in \pkg{SimInf} or
user-defined models.  The \code{SimInf\_model} class contains slots
(Table~\ref{table:SimInf:model}) to data structures that define the
disease-spread model and one slot \code{events} associated to a
\code{SimInf\_events} object, which contains slots
(Table~\ref{table:scheduled:events}) to incorporate and process
scheduled events.  Furthermore, the \code{SimInf\_model} object also
contains the output trajectory after running the core simulation
solver on the disease-spread model.

All disease-spread models in \pkg{SimInf} contains the \code{S4} class
\code{SimInf\_model}.  Moreover, the predefined disease-spread models
in \pkg{SimInf} have a generating function \citep{Chambers2008}, with
the same name as the model, which check parameters and initialize the
necessary data structures for that specific model.  After the model is
initialized, the simulation is started with a call to the \code{run}
method and if execution of the core solver is successful, it returns a
modified \code{SimInf\_model} object with a single stochastic solution
trajectory attached to it.  \pkg{SimInf} provides several utility
functions to facilitate post-processing and visualization of simulated
data, for example, \code{trajectory}, \code{prevalence} and
\code{plot}.

\begin{table}
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule
    Slot & Description\\
    \midrule

    \code{S} & Each column corresponds to a state transition, and
    execution of state transition $j$ amounts to adding the \code{S[,
        j]} column to the state vector \code{u[, i]} of node $i$ where
    the transition occurred.  Sparse matrix ($\Ncompartments \times
    \Ntransitions$) of object class \code{dgCMatrix}.\\

    \code{G} & Dependency graph that indicates the transition rates
    that need to be updated after a given state transition has
    occurred.  A non-zero entry in element \mbox{\code{G[i, j]}}
    indicates that transition rate $i$ needs to be recalculated if the
    state transition $j$ occurs.  Sparse matrix ($\Ntransitions \times
    \Ntransitions$) of object class \code{dgCMatrix}.\\

    \code{tspan} & A vector of increasing time points where the state
    of each node is to be returned.\\

    \code{U} & The result matrix with the number of individuals in
    each compartment in every node.  \mbox{\code{U[, j]}} contains the
    number of individuals in each compartment at \code{tspan[j]}.
    \mbox{\code{U[1:$\Ncompartments$, j]}} contains the number of
    individuals in each compartment in node $1$ at \code{tspan[j]}.
    \mbox{\code{U[($\Ncompartments$ + 1):(2 * $\Ncompartments$), j]}}
    contains the number of individuals in each compartment in node $2$
    at \code{tspan[j]} etc.  Integer matrix ($\Nnodes \Ncompartments
    \times \text{length}(\text{tspan})$).\\

    \code{U\_sparse} & It is possible to run the simulator and write
    the number of individuals in each compartment to the
    \code{U\_sparse} sparse matrix (\code{dgCMatrix}), which can save
    a lot of memory if the model contains many nodes and time-points,
    but where only a few of the data points are of interest.  If
    \code{U\_sparse} is non-empty when \code{run} is called, the
    non-zero entries in \code{U\_sparse} indicates where the number of
    individuals should be written to \code{U\_sparse}.  The layout of
    the data in \code{U\_sparse} is identical to \code{U}.  Please
    note that the data in \code{U\_sparse} is numeric and that the
    data in \code{U} is integer.\\

    \code{u0} & The initial number of individuals in each compartment
    in every node.  Integer matrix ($\Ncompartments \times
    \Nnodes$).\\

    \code{V} & The result matrix for the real-valued continuous
    state.  \mbox{\code{V[, j]}} contains the real-valued state of the
    system at \code{tspan[j]}.  Numeric matrix ($\Nnodes N_{ld} \times
    \text{length}(\text{tspan})$).\\

    \code{V\_sparse} & It is possible to run the simulator and write
    the real-valued continuous state to the \code{V\_sparse} sparse
    matrix (\code{dgCMatrix}), which can save a lot of memory if the
    model contains many nodes and time-points, but where only a few of
    the data points are of interest.  If \code{V\_sparse} is non-empty
    when \code{run} is called, the non-zero entries in
    \code{V\_sparse} indicates where the real-valued continuous state
    should be written to \code{V\_sparse}.  The layout of the data in
    \code{V\_sparse} is identical to \code{U}.\\

    \code{v0} & The initial value for the real-valued continuous
    state.  Numeric matrix ($N_{ld} \times \Nnodes$).\\

    \code{ldata} & A numeric matrix with local data specific to each
    node.  The column \code{ldata[, j]} contains the local data vector
    for node $j$.  The local data vector is passed as an argument to
    the transition rate functions and the post time step function.\\

    \code{gdata} & A numeric vector with global data that is common to
    all nodes.  The global data vector is passed as an argument to the
    transition rate functions and the post time step function.\\

    \code{events} & Scheduled events to modify the discrete state of
    individuals in a node at a pre-defined time $t$.  \code{S4} class
    \code{SimInf\_events}, see \S\ref{sec:events} and
    Table~\ref{table:scheduled:events}.\\

    \code{C\_code} & Character vector with optional model \proglang{C}
    code, see \S\ref{sec:extend}.  If non-empty, the \proglang{C} code
    is written to a temporary file when the \code{run} method is
    called.  The temporary file is compiled and the resulting DLL is
    dynamically loaded.  The DLL is unloaded and the temporary files
    are removed after running the model.\\

    \bottomrule
  \end{tabularx}
  \caption{Description of the slots in the S4 class
    \code{SimInf\_model} that defines the epidemiological model.
    $\Ntransitions$ is the number of state transitions in the model.
    $\Ncompartments$ is the number of compartments in the model.
    $\Nnodes$ is the number of nodes in the model.  $N_{ld}$ is the
    number of local data specific to each node and equals
    \code{dim(ldata)[1]}.}
  \label{table:SimInf:model}
\end{table}

\subsection{Specification of an epidemiological model}
\label{sec:model}

The within-node disease spread model in \pkg{SimInf} is specified as a
compartment model with the individuals divided into compartments
defined by discrete disease statuses.  The model is defined by the
slots in the \code{S4} class \code{SimInf\_model}
(Table~\ref{table:SimInf:model}).  The compartments contains the
number of individuals in each of the $\Ncompartments$ disease states
in every $\Nnodes$ nodes.

Equation~\ref{eq:numstep3}, the stochastic step, contains
$\Ntransitions$ state transitions and is processed using the two
slots, \code{S} and \code{G}.  The \code{S} slot is the state-change
matrix ($\Ncompartments \times \Ntransitions$) that determines how to
change the number of individuals in the compartments of a node when
the $j^{th}$ state transition occurs, where $1 \le j \le
\Ntransitions$.  Each row corresponds to one compartment and each
column to a state transition.  Let \code{u[, i]} be the number of
individuals in each compartment in node $i$ at time $t_i$.  To move
simulation time forward in node $i$ to $t_i = t_i + \tau_i$, the
vector \code{u[, i]} is updated according to the $j^{th}$ transition
by adding the state-change vector \code{S[, j]} to \code{u[, i]}.
After updating \code{u[, i]}, the transition rates must be
recalculated to obtain the time to the next event.  However, a state
transition might not need all transition rates to be recalculated.
The dependency graph \code{G} is a matrix ($\Ntransitions \times
\Ntransitions$) that determines which transition rates that need to be
recalculated.  A non-zero entry in element \code{G[k, j]} indicates
that transition rate \code{k} needs to be recalculated if the $j^{th}$
state transition occurs, where \mbox{$1 \le$ \code{k} $\le
  \Ntransitions$}.  Furthermore, the final step \eqref{eq:numstep3} is
incorporated using a model specific post time step callback to allow
update of the concentration variable $\Y$.

\begin{table}[!ht]
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule Slot & Description\\ \midrule

    \code{E} & Each row corresponds to one compartment in the model.
    The non-zero entries in a column indicate which compartments to
    sample individuals from when processing an event.  Which column to
    use for each event is specified by the \code{select} vector (see
    below).  \code{E} is a sparse matrix of class \code{dgCMatrix}.\\

    \code{N} & Determines how individuals in \textit{internal
      transfer} and \textit{external transfer} events are shifted to
    enter another compartment.  Each row corresponds to one
    compartment in the model.  The values in a column are added to the
    current compartment of sampled individuals to specify the
    destination compartment, for example, a value of \code{1} in an
    entry means that sampled individuals in this compartment are moved
    to the next compartment.  Which column to use for each event is
    specified by the \code{shift} vector (see below).  \code{N} is an
    integer matrix.\\

    \code{event} & Four event types are supported by the current
    solvers: \textit{exit}, \textit{enter}, \textit{internal
      transfer}, and \textit{external transfer}.  When assigning the
    events from a \code{data.frame}, they can either be coded as a
    numerical value or a character string: \textit{exit;} \code{0} or
    \code{'exit'}, \textit{enter;} \code{1} or \code{'enter'},
    \textit{internal transfer;} \code{2} or \code{'intTrans'}, and
    \textit{external transfer;} \code{3} or \code{'extTrans'}.
    Internally in \pkg{SimInf}, the event type is coded as a numerical
    value.\\

    \code{time} & Time of when the event occurs i.e., the event is
    processed when time is reached in the simulation.  \code{time} is
    an integer vector.\\

    \code{node} & The node that the event operates on.  Also the
    source node for an \textit{external transfer} event.  \code{node}
    is an integer vector, where $1 \le$ \code{node[i]} $\le
    \Nnodes$.\\

    \code{dest} & The destination node for an \textit{external
      transfer} event i.e., individuals are moved from \code{node} to
    \code{dest}, where $1 \le$ \code{dest[i]} $\le \Nnodes$.  Set
    \code{event = 0} for the other event types.  \code{dest} is an
    integer vector.\\

    \code{n} & The number of individuals affected by the event.
    \code{n} is an integer vector, where \code{n[i]} $\ge 0$.\\

    \code{proportion} & If \code{n[i]} equals zero, the number of
    individuals affected by \code{event[i]} is calculated by summing
    the number of individuals in the compartments determined by
    \code{select[i]} and multiplying with \code{proportion[i]}.
    \code{proportion} is a numeric vector, where $0 \le$
    \code{proportion[i]} $\le 1$.\\

    \code{select} & To process an \code{event[i]}, the compartments
    affected by the event are specified with \code{select[i]} together
    with the matrix \code{E}, where \code{select[i]} determines which
    column in \code{E} to use.  The specific individuals affected by
    the event are proportionally sampled from the compartments
    corresponding to the non-zero entries in the specified column in
    \code{E[, select[i]]}, where \code{select} is an integer vector.\\

    \code{shift} & Determines how individuals in \textit{internal
      transfer} and \textit{external transfer} events are shifted to
    enter another compartment.  The sampled individuals are shifted
    according to column \code{shift[i]} in matrix \code{N} i.e.,
    \code{N[, shift[i]]}, where \code{shift} is an integer vector.
    See above for a description of \code{N}.\\

    \bottomrule
  \end{tabularx}
  \caption{Description of the slots in the S4 class
    \code{SimInf\_events} that holds data to process scheduled events
    to modify the discrete state of individuals in a node at a
    pre-defined time $t$.  Each index, \code{i}, of the vectors
    represent one event.  $\Nnodes$ is the number of nodes in the
    model.}
  \label{table:scheduled:events}
\end{table}

Model-specific data that is passed to the transition-rate functions
and the post time-step function are stored in the two slots:
\code{ldata} and \code{gdata} in the \code{SimInf\_model} object.  The
\code{ldata} matrix holds local data for each node where \code{ldata[,
    i]} is the data vector for node $i$.  Data that is global, i.e.,
shared between nodes, is stored in the \code{gdata} vector.

The \code{events} slot in the \code{SimInf\_model} holds data to
process the scheduled events, further described in \S\ref{sec:events}.

During simulation of one trajectory, the state of the system is
written to the two matrices \code{U} and \code{V}.  This happens at
each occasion the simulation time passes a time point in \code{tspan},
a vector of increasing time points.  The first and last element in
\code{tspan} determines the start- and end-point of the simulation.
The column \code{U[, m]} contains the number of individuals in each
compartment in every node at \code{tspan[m]}, where $1 \le$ \code{m}
$\le$ \code{length(tspan)}.  The first $\Ncompartments$ rows in
\code{U} contains the compartments of the first node.  The next
$\Ncompartments$ rows contains the compartments of the second node
etc.  The \code{V} matrix contains output from continuous state
variables.  The column \code{V[, m]} contains the values at
\code{tspan[m]}.  The rows are grouped per node and the number of rows
per node is determined by the number of continuous state variables in
that specific model.  It is also possible to configure the simulator
to write the state of the system to the sparse matrices
\code{U\_sparse} and \code{V\_sparse}, which can save a lot of memory
if the model contains many nodes and time-points, but where only a few
of the data points are of interest.  In order to use this feature,
call the \code{U} and \code{V} methods (before running a trajectory)
with a \code{data.frame} that specify the nodes, time-points and
compartments where the simulator should write the state of the system.
The initial state in each node is specified by the two matrices
\code{u0} and \code{v0} where \code{u0[, i]} is the initial number of
individuals in each compartment at node $i$ and \code{v0[, i]} is the
initial continuous state in node $i$.

\begin{table}[!ht]
  \small
  \begin{tabularx}{\textwidth}{l X}
    \toprule
    Argument & Description\\
    \midrule
    \code{v\_new} & The continuous state vector in the node after the
    post time step.  Exists only in \code{PTSFun}.\\
    \code{u} & The compartment state vector in the node.\\
    \code{v} & The current continuous state vector in the node.\\
    \code{ldata} & The local data vector for the node.\\
    \code{gdata} & The global data vector that is common to all nodes.\\
    \code{node} & The node index.  Note the node index is zero-based,
    i.e., the first node is $0$.\\
    \code{t} & Current time in the simulation.\\
    \bottomrule
  \end{tabularx}
  \caption{Description of the arguments to the transition rate
    functions (\code{TRFun}) and the post time step function
    (\code{PTSFun}).}
  \label{table:arguments}
\end{table}

\subsection{Specification of scheduled events}
\label{sec:events}

The scheduled events are used to modify the discrete state of
individuals in a node at a pre-defined time $t$.  There are four
different types of events; \textit{enter}, \textit{internal transfer},
\textit{external transfer} and \textit{exit}. The \textit{enter} event
adds individuals to a node, for example, due to births. The
\textit{internal transfer} event moves individuals between
compartments within one node, for example, ageing of individuals in a
model with several age compartments or vaccination to move individuals
to a vaccinated compartment. The \textit{external transfer} event
moves individuals from compartments in one node to compartments in a
destination node. Finally, the \textit{exit} event removes individuals
from a node, for example, due to slaughter. The event types are
classified into those that operate on the compartments of a single
node $E_1 = \{\text{\textit{enter}, \textit{internal transfer},
  \textit{exit}}\}$ and those that operate on the compartments of two
nodes $E_2 = \{\text{\textit{external transfer}}\}$.  The parallel
algorithm processes these two classes of events differently, see
Appendix~\ref{sec:pseudo-code} for pseudo-code of the core simulation
solver.  The scheduled events are processed when simulation time
reaches the time for any of the events.  Events that are scheduled at
the same time are processed in the following order: \textit{exit},
\textit{enter}, \textit{internal transfer} and \textit{external
  transfer}.

The S4 class \code{SimInf\_events} contains slots with data structures
to process events (Table~\ref{table:scheduled:events}).  The slots
\code{event}, \code{time}, \code{node}, \code{dest}, \code{n},
\code{proportion}, \code{select} and \code{shift}, are vectors of
equal length.  These vectors hold data to process one event: \code{e},
where $1 <$ \code{e} $\leq$ \code{length(event)}.  The event type and
the time of the event are determined by \code{event[e]} and
\code{time[e]}, respectively.  The compartments that \code{event[e]}
operates on, are specified by \code{select[e]} together with the slot
\code{E}.  Each row $\{1, 2, ..., \Ncompartments\}$ in the sparse
matrix \code{E}, represents one compartment in the model.  Let \code{s
  <- select[e]}, then each non-zero entry in the column \code{E[, s]}
includes that compartment in the \code{event[e]} operation.  The
definitions of all of these operations are a bit involved and to
quickly get an overview, schematic diagrams illustrating all of them
have been prepared, we refer to
Figures~\ref{fig:exit},\ref{fig:enter},\ref{fig:external},\ref{fig:internal},\ref{fig:external:shift}
in Appendix~\ref{sec:illustration-scheduled-events}.

\subsubsection{Processing of an enter event}

The \textit{enter} event adds \code{n[e]} individuals to one
compartment at \code{node[e]}, where the compartment is specified by a
non-zero entry in the row for the compartment in column \code{E[, s]}.
Please note that, if the column \code{E[, s]} contains several
non-zero entries, the individuals are added to the compartment
represented by the first non-zero row in column \code{E[, s]}.  The
values of \code{dest[e]}, \code{proportion[e]} and \code{shift[e]},
described below, are not used when processing an \textit{enter} event.
See Figure~\ref{fig:enter} in
Appendix~\ref{sec:illustration-scheduled-events} for an illustration
of a scheduled \textit{enter} event.

\subsubsection{Processing of an internal transfer event}

The \textit{internal transfer} event moves \code{n[e]} individuals
into new compartments within \code{node[e]}.  However, if \code{n[e]}
equals zero, the number of individuals to move is calculated by
multiplying the \code{proportion[e]} with the total number of
individuals in the compartments represented by the non-zero entries in
column \mbox{\code{E[, s]}}.  The individuals are then proportionally
sampled and removed from the compartments specified by \code{E[, s]}.
The next step is to move the sampled individuals to their new
compartment using the matrix \code{N} and \code{shift[e]}, where
\code{shift[e]} specifies which column in \code{N} to use.  Each row
$\{1, 2, ..., \Ncompartments\}$ in \code{N}, represents one
compartment in the model and the values determine how to move sampled
individuals before adding them to \code{node[e]} again.  Let \code{q
  <- shift[e]}, then each non-zero entry in \code{N[, q]} defines the
number of rows to move sampled individuals from that compartment i.e.,
sampled individuals from compartment \code{p} are moved to compartment
\code{N[p, q] + p}, where $1 \leq$ \code{N[p, q] + p} $\le
\Ncompartments$.  The value of \code{dest[e]}, described below, is not
used when processing an \textit{internal transfer} event.  See
Figure~\ref{fig:internal} in
Appendix~\ref{sec:illustration-scheduled-events} for an illustration
of a scheduled \textit{internal transfer} event.

\subsubsection{Processing of an external transfer event}

The \textit{external transfer} event moves individuals from
\code{node[e]} to \code{dest[e]}.  The sampling of individuals from
\code{node[e]} is performed in the same way as for an \textit{internal
  transfer} event.  The compartments at \code{node[e]} are updated by
subtracting the sampled individuals while adding them to the
compartments at \code{dest[e]}.  The sampled individuals are added to
the same compartments in \code{dest[e]} as in \code{node[e]}, unless
\code{shift[e]} $> 0$.  In that case, the sampled individuals change
compartments according to \code{N} as described in processing an
\textit{internal transfer} event before adding them to \code{dest[e]}.
See Figures \ref{fig:external} and \ref{fig:external:shift} in
Appendix~\ref{sec:illustration-scheduled-events} for illustrations of
scheduled \textit{external transfer} events.

\subsubsection{Processing of an exit event}

The \textit{exit} event removes individuals from \code{node[e]}.  The
sampling of individuals from \code{node[e]} is performed in the same
way as for an \textit{internal transfer} event.  The compartments at
\code{node[e]} are updated by subtracting the sampled individuals.
The values of \code{dest[e]} and \code{shift[e]} are not used when
processing an \textit{exit} event.  See Figure~\ref{fig:exit} in
Appendix~\ref{sec:illustration-scheduled-events} for an illustration
of a scheduled \textit{exit} event.

\subsection{Core simulation solver}

The \pkg{SimInf} package uses the ability to interface compiled code
from R \cite{Chambers2008}.  The solver is implemented in the compiled
language \proglang{C} \citep{Kernighan1988} and is called from
\proglang{R} using the \code{.Call()} interface \citep{Chambers2008}.
Using compiled rather than interpreted code ensures high performance
when running the model.  To improve performance further, the solver
uses \proglang{OpenMP} to divide work over multiple processors and
perform computations in parallel.  The solver uses GSL to generate
random numbers for the simulation.

\subsubsection{Function pointers}

The flexibility of the solver is partly achieved by using function
pointers \citep{Kernighan1988}.  A function pointer is a variable that
stores the address of a function that can be used to invoke the
function.  This provides a simple way to incorporate model specific
functionality into the solver.  A model must define one transition
rate function for each state transition in the model.  These functions
are called by the solver to calculate the transition rate for each
state transition in each node.  The output from the transition rate
function depends only on the state of the system at the current time.
However, the output is unique to a model and data are for that reason
passed on to the function for the calculation.  Furthermore, a model
must define the post time step function.  This function is called once
for each node each time the simulation of the continuous-time Markov
chain reaches the next day (or, more generally, the next unit of time)
and after the $E_1$ and $E_2$ events have been processed.  The main
purpose of the post time step function is to allow for a model to
update continuous state variables in each node.

The transition rate function is defined by the data type \code{TRFun}
and the post time step function by the data type \code{PTSFun}.  These
data types are defined in the header file \texttt{'src/SimInf.h'} and
shown below.  The arguments \code{v\_new}, \code{u}, \code{v},
\code{ldata}, \code{gdata}, \code{node}, and \code{t} of the functions
are described in Table~\ref{table:arguments}.

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[language=C]
  typedef double (*TRFun)(const int *u, const double *v, const double *ldata,
                          const double *gdata, double t);

  typedef int (*PTSFun)(double *v_new, const int *u, const double *v,
                        const double *ldata, const double *gdata,
                        int node, double t);
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\subsubsection{Overview of the solver}

Here follows an overview of the steps in the solver to run one
trajectory, see Appendix~\ref{sec:pseudo-code} for pseudo-code of the
core simulation solver and \texttt{'src/core/SimInf\_solver.c'} for
the source code.  The simulation starts with a call to the \code{run}
method with the model as the first argument and optionally the number
of threads to use and a seed for the random number generator.  This
method will first call the validity method on the model to perform
error-checking and then call a model specific \proglang{C} function to
initialize the function pointers to the transition rate functions and
the post time step function of the model.  Subsequently, the
simulation solver is called to run one trajectory using the model
specific data, the transition rate functions, and the post time step
function.  If the \code{C\_code} slot is non-empty, the \proglang{C}
code is written to a temporary file when the \code{run} method is
called.  The temporary file is compiled using \code{'R CMD SHLIB'} and
the resulting DLL is dynamically loaded.  The DLL is unloaded and the
temporary files are removed after running the model.  This is further
described in \S\ref{sec:extend}.

The solver simulates the trajectory in parallel if \proglang{OpenMP}
is available.  The default is to use all available threads.  However,
the user can specify the number of threads to use.  The solver divides
data for the $\Nnodes$ nodes and the $E_1$ events over the number
threads.  All $E_1$ events that affect node $i$ is processed in the
same thread as node $i$ is simulated in.  The $E_2$ events are
processed in the main thread.

The solver runs the continuous-time Markov chain for each node $i$.
For every time step $\tau_i$, the count in the compartments at node
$i$ is updated according to the state transition that occurred
(\S\ref{sec:model}).  The time to the next event is computed, after
recalculating affected transition rate functions (\S\ref{sec:model}).
When simulated time reaches the next day in node $i$ the $E_1$ events
are processed for that node (\S\ref{sec:events}).  The $E_2$ events
are processed when all nodes reaches the next day
(\S\ref{sec:events}).  Thereafter, the post time step function is
called to allow the model to incorporate model specific actions.  When
simulated time passes the next time in \code{tspan}, the count of the
compartments and the continuous state variables are written to
\code{U} and \code{V}.

%**************************************************************************

\section[Model construction and data analysis: Basic examples]{%
  Model construction and data analysis: Basic examples}
\label{sec:examples}

\subsection[A first example: The SIR model]{%
  A first example: The \code{SIR} model}
\label{sec:example-SIR}

\subsubsection[Specification of the SIR model without scheduled events]{%
  Specification of the \code{SIR} model without scheduled events}

This section illustrates the specification of the predefined
\code{SIR} model, which contains the three compartments susceptible
(\code{S}), infected (\code{I}) and recovered (\code{R}), where $\{S,
I, R\}$ represents the number of individuals in each of the three
compartments, respectively.  The transmission route of infection to
susceptible individuals is through direct contact between susceptible
and infected individuals.  The \code{SIR} model has two state
transitions in each node $i$,
\begin{align}
\label{eq:SIR}
\begin{array}{rcl}
  S_i & \xrightarrow{\beta S_i I_i / (S_i+I_i+R_i)} & I_i, \\
  I_i &\xrightarrow{\gamma I_i} & R_i,
  \end{array}
\end{align}
where $\beta$ is the transmission rate and $\gamma$ is the recovery
rate.  The state change matrix \code{S} and the dependency graph
\code{G} for the \code{SIR} model are defined as follows

\begin{figure}[t]
  \begin{center}
    \includegraphics[width=1.0\linewidth]{img/SIR.pdf}
  \end{center}
  \caption{Schematic representation of the \code{SIR} compartment
    model in two nodes.  The \code{SIR} model is defined by the three
    disease states susceptible (S), infected (I), and recovered (R).
    \textit{i)} State transitions between the $S$, $I$, and $R$
    compartments are modeled as a continuous-time discrete-state
    Markov process.  The other state transitions are due to scheduled
    events: \textit{ii)} \textit{enter} events, \textit{iii)}
    \textit{exit} events, and \textit{iv)} \textit{external transfer}
    events.  \label{fig:SIR-model}}
\end{figure}

{\small
\[
\mathbf{S} =
\bordermatrix{
    & \enspace 1 & \enspace 2 \cr
  S & -1 & \hphantom{-}0 \cr
  I & \hphantom{-}1 & -1 \cr
  R & \hphantom{-}0 & \hphantom{-}1} \qquad
\mathbf{G} =
\bordermatrix{
                  & 1 & 2 \cr
  S \rightarrow I & 1 & 1 \cr
  I \rightarrow R & 1 & 1}
\]
}

The first step in creating an \code{SIR} model object is to define
\code{u0}, a \code{data.frame} with the initial condition, i.e., the
number individuals in each compartment when the simulation starts.  We
will start in a node with 100 individuals of which 1 is infected.

<<SIR-u0>>=
u0 <- data.frame(S = 99, I = 1, R = 0)
@

Next, we define the time period over which we want to simulate the
disease spread.  This is a vector of integers in units of time or a
vector of dates.  You specify those time points in the vector that you
wish the model to return results for.  The model itself does not run
in discrete time steps, but continuous time, so this vector affects
only the start and end points of the simulation and the results that
you receive from the model, not the internal calculations of disease
transitions through time.  In this example we simulate for 6 months
returning results every $7^{th}$ day

<<SIR-tspan>>=
tspan <- seq(from = 1, to = 6 * 30, by = 7)
@

Before we can simulate from the model, we need to specify the
transmission rate, $\beta$, and the recovery rate, $\gamma$.

<<SIR-model>>=
model <- SIR(u0 = u0, tspan = tspan, beta = 0.16, gamma = 0.077)
@

We are now ready to run the model with these parameters and simulate
data.  We use the \code{threads} and \code{seed} arguments for
reproducibility.

<<SIR-run>>=
result <- run(model = model, threads = 1, seed = 22)
@

The \code{result} object contains the number of individuals in each
compartment at the time points specified in \code{tspan} and can be
extracted using the \code{trajectory} method as a \code{data.frame}.
Each line in the \code{data.frame} represents the information from one
node and time-point.  Below is an excerpt of the trajectory data

<<SIR-U>>=
head(trajectory(model = result))
@

The package \pkg{SimInf} has a \code{plot} method for objects of class
\code{SimInf_model}, such as the object \code{result}, which we can
use to display the outcome of the disease simulation in the single
node (Figure~\ref{fig:SIR-proportion}).

<<eval=FALSE>>=
plot(result)
@

\begin{figure}
  \begin{center}
<<SIR-plot-proportion, echo=FALSE,fig=TRUE>>=
plot(result)
@
  \end{center}
  \caption{Example of simulated data from one realization of the
    \code{SIR} model (Equation~\ref{eq:SIR}) in one node, starting
    with 99 susceptible, 1 infected, and 0 recovered
    individuals. \label{fig:SIR-proportion}}
\end{figure}

In order to run a simulation with multiple nodes we need to just add
those nodes to the initial \code{u0} \code{data.frame} that we
generate to start the model. If you were doing your own modeling of
many nodes, you would have a \code{data.frame} of your node population
that you read from, for example, a spreadsheet.  For now we will just
add another nodes to the \code{data.frame} here in \proglang{R}.

<<SIR-multiple-nodes>>=
u0 <- data.frame(S = c(99, 90), I = c( 1,  2), R = c( 0,  0))
model <- SIR(u0 = u0, tspan = tspan, beta = 0.16, gamma = 0.077)
result <- run(model = model, threads = 1, seed = 22)
@

If we inspect an excerpt of the trajectory, it now includes results
from two nodes above one another for each time point in the
\code{tspan} vector.

<<SIR-U-multiple-nodes>>=
head(trajectory(model = result))
@

\subsubsection[Specification of scheduled events in the SIR model]{%
  Specification of scheduled events in the \code{SIR} model}

In this example, we will continue to work with the predefined
\code{SIR} model to explore a within node disease spread similar to
the first SIR example but with the additional feature that individuals
enter and exit the simulation and that the disease can spread between
nodes via movements of infected individuals between nodes.

We will start with the inclusion of a set of individuals that are
moved between nodes in the network (\textit{external transfer}
events). These events are predefined prior to the simulation and are
applied during the simulation process. For example, if your simulation
time is in days, then after each day, \pkg{SimInf} will apply the
events in the data and move individuals between nodes.  In the
following example we have five nodes with movements between nodes. To
illustrate the movements themselves, we have only started with 30
individuals in the first node and the other four are empty, and we
will run the simulation for five time steps:

<<SIR-u0-multiple-nodes>>=
u0 <- data.frame(S = c(10, 0, 0, 0, 0), I = c(10, 0, 0, 0, 0),
R = c(10, 0, 0, 0, 0))
@

Now we will define 6 scheduled events to include in the simulation.
Below is a \code{data.frame}, that contains the events.  Interpret it
as follows:

\begin{enumerate}
\itemsep0em
\item In time step 2 we add 2 susceptible individuals to node 2
\item In time step 3 we move 2 individuals from node 1 to node 3
\item In time step 4 we remove 1 individual from node 2
\item In time step 4 we move 1 individual from node 1 to node 3
\item In time step 4 we move 1 individual from node 1 to node 4
\item In time step 5 we move 2 individuals from node 1 to node 5
\end{enumerate}

<<SIR-events, echo=FALSE>>=
events <- data.frame(
event = c("enter", "extTrans", "exit", "extTrans", "extTrans", "extTrans"),
time = c(2, 3, 4, 4, 4, 5), node = c(2, 1, 2, 1, 1, 1),
dest = c(0, 3, 0, 3, 4, 5), n = c(2, 1, 1, 1, 1, 2),
proportion = c(0, 0, 0, 0, 0, 0), select = c(1, 2, 2, 2, 2, 2),
shift = c(0, 0, 0, 0, 0, 0))
@

<<SIR-events-show>>=
events
@

Now we are ready to run the simulation using the events and the
disease spread model as we did in earlier examples:

<<U-model-events>>=
model <- SIR(u0 = u0, tspan = 1:5, events = events, beta = 0.16,
gamma = 0.077)
result <- run(model = model, threads = 1, seed = 22)
trajectory(model = result)
@

If you inspect the result of this very simple simulation, you will see
that 2 individuals were added to node 2, of which one individual was
later removed, and that some individuals were removed from node 1 and
placed in nodes 3, 4, and 5.  So far this is not really
earth-shattering, but if we do this again with a few more individuals
then we can see how disease can spread from an infected node to a
non-infected one. We will start with 5 nodes again, but node 1 is
infected and nodes 2--5 now each have 100 susceptible and the
simulation will run for 75 days:

<<SIR-u0-multiple-nodes-II>>=
u0 <- data.frame(S = c(90, 100, 100, 100, 100), I = c(10, 0, 0, 0, 0),
R = c(0, 0, 0, 0, 0))
@

And then we have a few movements of individuals from node 1 to the others:

<<SIR-events-II, echo=FALSE>>=
events <- data.frame(event = c("extTrans", "extTrans", "extTrans", "extTrans"),
time = c(3, 25, 5, 10), node = c(1, 1, 1, 1), dest = c(3, 2, 3, 3),
n = c(1, 9, 1, 5), proportion = c(0, 0, 0, 0), select = c(2, 2, 2, 2),
shift = c(0, 0, 0, 0))
@

<<SIR-events-II-show>>=
events
@

Initialize and run the model

<<SIR-events-II-run>>=
model <- SIR(u0 = u0, tspan = 1:75, events = events, beta = 0.16,
gamma = 0.077)
result <- run(model = model, threads = 1, seed = 5)
@

Figure~\ref{fig:SIR-spaghetti} shows the result from running the
model.  Note the time that it takes for node 2 to become positive
relative to the movements.  On day 25, 10 individuals are moved to the
node causing the outbreak.  Also despite the fact that we moved
individuals from node 1 to node 3, there was no outbreak in node 3.
This is because of the random selection process that select
susceptible, infected or recovered individuals to move between the
nodes.

<<SIR-spaghetti, eval=FALSE>>=
plot(result, N = TRUE, spaghetti = TRUE, compartments = "I")
@

\begin{figure}
  \begin{center}
<<SIR-spaghetti-plot, echo=FALSE, fig=TRUE>>=
plot(result, N = TRUE, spaghetti = TRUE, compartments = "I")
@
  \end{center}
  \caption{One realization of the number of infected individuals in
    each node when simulating 75 days of an \code{SIR} model in 5
    nodes, starting with 90 susceptible and 10 infected individuals in
    node 1 and 100 susceptible individuals in nodes 2--5, and moving
    individuals from node 1 to nodes 2 and
    3. \label{fig:SIR-spaghetti}}
\end{figure}

\subsubsection[C code for the SIR model]{%
  \proglang{C} code for the \code{SIR} model}

The \proglang{C} code for the \code{SIR} model is defined in the
source file \texttt{'src/models/SIR.c'}.  This file contains the
\code{SIR_run} function to initialize the core solver
(Listing~\ref{lst:SIRrun} in Appendix~\ref{sec:C-code-SIR}), the
transition rate functions (Listing~\ref{lst:trSIR} in
Appendix~\ref{sec:C-code-SIR}) and the post time step function
(Listing~\ref{lst:ptsSIR} in Appendix~\ref{sec:C-code-SIR}).

\subsection[A second example: The SISe3_sp model]{%
  A second example: The \code{SISe3\_sp} model}
\label{sec:example-SISe3_sp}

This section illustrates the specification of the \code{SISe3\_sp}
model, which is also predefined in the \pkg{SimInf} package.  Two
additional features, compared to the \code{SIR} model, are used by the
\code{SISe3\_sp} model: ageing of individuals by \textit{internal
  transfer} events, and usage of the real valued continuous state $V$.
The \code{SISe3\_sp} model contains the two compartments susceptible
(\code{S}) and infected (\code{I}) divided into the three age
categories $j = \{1, 2, 3\}$ and the local environmental compartment
(\code{e}) contaminated with free living pathogens
(Figure~\ref{fig:SISe3_sp}).  Moreover, nodes are connected spatially
with local spread of the contaminated environmental compartment among
proximal nodes.  The transmission route of infection to susceptible
individuals is indirect via the local environment, contaminated by
infected individuals.  The number of individuals in each of the six
compartments $\{S_1, I_1, S_2, I_2, S_3, I_3\}$ in node $i$ at time
$t$ is \mbox{\code{u[, i]}}.  The \code{SISe3\_sp} model has two state
transitions within each of the three age categories,
\begin{align}
\label{eq:vtectrans}
\begin{array}{rcl}
  S_{ij} & \xrightarrow{\upsilon_j \varphi_i} & I_{ij}, \\
  I_{ij} & \xrightarrow{\gamma_j} & S_{ij},
  \end{array}
\end{align}

where the state transition from susceptible to infected depends on the
concentration of the environmental contamination $\varphi_i(t)$ of the
pathogen in node $i$ and the indirect transmission rate $\upsilon_j$.
The state transition from infected to susceptible depends on the
recovery rate $\gamma_j$.  Finally, the environmental infectious
pressure is evolved by
\begin{equation}
  \label{eq:envInfPressure-local-spread}
  \frac{d \varphi_i(t)}{dt}= \frac{\alpha I_i(t)}{N_i(t)} +
  \sum_k{\frac{\varphi_k(t) N_k(t) - \varphi_i(t) N_i(t)}{N_i(t)}
    \cdot \frac{D}{d_{ik}}} - \beta(t) \varphi_i(t),
\end{equation}

where the constant $\alpha$ is the average shedding rate of the
pathogen to the environment per infected individual, and $N_i = S_i +
I_i$ the size of node $i$.  The decay and removal of the pathogen is
captured by $\beta$, which is allowed to vary with time.  A spatial
component with local spread among proximal nodes is also included in
the model, where $D$ is the rate of the local spread and $d_{ik}$ the
distance between the two holdings $i$ and $k$.  When running a
trajectory of the \code{SISe3\_sp} model, the environmental infectious
pressure $\varphi_i(t)$ in each node is evolved in the post-time-step
function by the Euler forward method. The value of $\varphi_i(t)$ is
saved to the \code{V} matrix at the time-points specified by
\code{tspan}.

\begin{figure}
  \begin{center}
    \includegraphics[width=0.70\linewidth]{img/SISe3_sp.pdf}
  \end{center}
  \caption{Schematic representation of the \code{SISe3\_sp}
    compartment model in two nodes.  The \code{SISe3\_sp} model is
    defined by the two disease states susceptible (S) and infected (I)
    in three age categories and indirect transmission via an
    environmental infectious pressure $\varphi_i$.  \textit{i)} State
    transitions between the $S$ and $I$ compartments are modeled as a
    continuous-time discrete-state Markov process.  The other state
    transitions are due to scheduled events: \textit{ii)}
    \textit{enter} events, \textit{iii)} \textit{internal transfer}
    events, \textit{iv)} \textit{external transfer} events, and
    \textit{v)} \textit{exit} events.  The environmental infectious
    pressure $\varphi_i$ is modeled with an ordinary differential
    equation and by default evolved by the Euler forward
    method.  \label{fig:SISe3_sp}}
\end{figure}

\subsubsection[Illustration of the stochastic step in the SISe3_sp model]{%
  Illustration of the stochastic step in the \code{SISe3\_sp} model}

To illustrate the stochastic step in Equation~\ref{eq:numstep3},
consider that the number of individuals in each compartment in node
$i$ \code{u[, i]} at time $t$ is $\{12, 3, 63, 14, 92, 2\}$ and that
the time to the next state transition is $\tau_i$.  Furthermore,
assume that the next state transition is infected to susceptible in
the first age category which corresponds to the second column in the
state change matrix \code{S}.  Thus, updating the compartments
corresponds to adding \code{S[, 2]} to \code{u[, i]}, which gives
$\{13, 2, 63, 14, 92, 2\}$.  This also implies that the transition
rates for the two transitions $S_{i,1} \rightarrow I_{i,1}$ and
$I_{i,1} \rightarrow S_{i,1}$ must be recalculated according to
\code{G[, 2]}.

{\small
\[
\mathbf{S} =
\bordermatrix{
      & \enspace 1 & \enspace 2 & \enspace 3 & \enspace 4 & \enspace 5 & \enspace 6 \cr
  S_1 & -1 & \hphantom{-}1 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 \cr
  I_1 & \hphantom{-}1 & -1 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 \cr
  S_2 & \hphantom{-}0 & \hphantom{-}0 & -1 & \hphantom{-}1 & \hphantom{-}0 & \hphantom{-}0 \cr
  I_2 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}1 & -1 & \hphantom{-}0 & \hphantom{-}0 \cr
  S_3 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & -1 & \hphantom{-}1 \cr
  I_3 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}0 & \hphantom{-}1 & -1 } \qquad
\mathbf{G} =
\bordermatrix{
                      & 1 & 2 & 3 & 4 & 5 & 6 \cr
  S_1 \rightarrow I_1 & 1 & 1 & 0 & 0 & 0 & 0 \cr
  I_1 \rightarrow S_1 & 1 & 1 & 0 & 0 & 0 & 0 \cr
  S_2 \rightarrow I_2 & 0 & 0 & 1 & 1 & 0 & 0 \cr
  I_2 \rightarrow S_2 & 0 & 0 & 1 & 1 & 0 & 0 \cr
  S_3 \rightarrow I_3 & 0 & 0 & 0 & 0 & 1 & 1 \cr
  I_3 \rightarrow S_3 & 0 & 0 & 0 & 0 & 1 & 1 }
\]
}

\subsubsection[Specification of scheduled events in the SISe3_sp model]{%
  Specification of scheduled events in the \code{SISe3\_sp} model}

The \code{SISe3\_sp} model have been specified to handle births,
imports, ageing, moving and exits of individuals
(Table~\ref{table:SISe3_sp:events} in
Appendix~\ref{sec:illustration-scheduled-events}).  When individuals
enter the model (births, imports), they are added to the susceptible
state in the age category specified by column 1, 2 or 3 in \code{E}.
The columns 4, 5 and 6 in \code{E} are used for the other events
(ageing, moving, exit) to sample individuals from the susceptible and
infected states from each of the three ages categories.  To move the
sampled individuals in a \textit{internal transfer} event (ageing)
from age category 1 to age category 2, the susceptible and infected
states should shift two steps to the corresponding state in age
category 2, as specified in \code{N[, 1]}.  Similarly, \code{N[, 2]}
move susceptible and infected individuals from age category 2 to age
category 3.

{\small
\[
\mathbf{E} =
\bordermatrix{
      & 1 & 2 & 3 & 4 & 5 & 6 \cr
  S_1 & 1 & 0 & 0 & 1 & 0 & 0 \cr
  I_1 & 0 & 1 & 0 & 1 & 0 & 0 \cr
  S_2 & 0 & 0 & 1 & 0 & 1 & 0 \cr
  I_2 & 0 & 0 & 0 & 0 & 1 & 0 \cr
  S_3 & 0 & 0 & 0 & 0 & 0 & 1 \cr
  I_3 & 0 & 0 & 0 & 0 & 0 & 1 } \qquad
\mathbf{N} =
\bordermatrix{
      & 1 & 2 \cr
  S_1 & 2 & 0 \cr
  I_1 & 2 & 0 \cr
  S_2 & 0 & 2 \cr
  I_2 & 0 & 2 \cr
  S_3 & 0 & 0 \cr
  I_3 & 0 & 0 }
\]
}

\subsubsection[Case study using the SISe3_sp model]{%
  Case study using the \code{SISe3\_sp} model}

In this section we will demonstrate how to construct and use the
\code{SISe3\_sp} model together with synthetic cattle events and
population data included with the package \pkg{SimInf}.  The data
defines the initial population divided into three age categories (0
days $\le$ \textit{age 1} $<$ 120 days, 120 days $\le$ \textit{age 2}
$<$ 365 days and \textit{age 3} $\ge$ 365 days) in 1600 nodes and
scheduled events over $4 \times 365$ days.  The two data sets for the
model are loaded with

<<load-SISe3sp-events>>=
data("u0_SISe3", package = "SimInf")
data("events_SISe3", package = "SimInf")
@

To model local spread of the environmental infectious pressure among
proximal nodes, we have to generate a distance matrix.  Let us use the
synthetic data set \code{nodes} included in the \pkg{SimInf} package,
which defines a cattle population consisting of 1600 herds located in
a 50 square kilometer region, and let proximal neighbors be defined as
neighbors within 2500m.

<<load-nodes>>=
data("nodes", package = "SimInf")
d <- distance_matrix(x = nodes$x, y = nodes$y, cutoff = 2500)
@

Next we define \code{tspan} to simulate for 4 consecutive years
returning the results every $7^{th}$ day

<<create-SISe3sp-tspan>>=
tspan <- seq(from = 1, to = 4 * 365, by = 7)
@

We are now ready to create an \code{SISe3_sp} object using the
\code{SISe3_sp} generating method.  The parameters in the example were
chosen such that the proportion of infected nodes in a trajectory is
about 10\% and have a seasonal pattern.  We assume that the average
duration of infection is 10 days in all age categories, such that the
recovery rate $\gamma_{1,2,3} = 0.1$ per animal per day, and assume
that the indirect transmission rate of the environmental infectious
pressure $\gamma$ is equal in all age categories.  Moreover, we fix
the average shedding rate $\alpha = 1$ and allow the decay of the
bacteria to vary in four seasonal intervals, $\beta_1, ..., \beta_4$
over the year. The end point (day of the year) for each season
\code{beta\_t1}, ..., \code{beta\_t4} is determined by \code{end\_t1},
..., \code{end\_t4}, respectively. We let the local environmental
infectious pressure $\varphi_i = 0$ at the beginning of the simulation
and let 10\% of the herds start with 5\% infected individuals.

<<create-SISe3sp-u0>>=
set.seed(123)
i <- sample(x = 1:1600, size = 160)
u0_SISe3$I_1[i] <- as.integer(u0_SISe3$S_1[i] * 0.05)
u0_SISe3$I_2[i] <- as.integer(u0_SISe3$S_2[i] * 0.05)
u0_SISe3$I_3[i] <- as.integer(u0_SISe3$S_3[i] * 0.05)
u0_SISe3$S_1[i] <- u0_SISe3$S_1[i] - u0_SISe3$I_1[i]
u0_SISe3$S_2[i] <- u0_SISe3$S_2[i] - u0_SISe3$I_2[i]
u0_SISe3$S_3[i] <- u0_SISe3$S_3[i] - u0_SISe3$I_3[i]
@

Let us now construct an \code{SISe3\_sp} model object

<<create-SISe3sp>>=
model <- SISe3_sp(u0 = u0_SISe3, tspan = tspan, phi = rep(0, 1600),
events = events_SISe3, upsilon_1 = 0.013, upsilon_2 = 0.013, upsilon_3
= 0.013, gamma_1 = 0.1, gamma_2 = 0.1, gamma_3 = 0.1, alpha = 1,
beta_t1 = 0.095, beta_t2 = 0.12, beta_t3 = 0.10, beta_t4 = 0.15,
end_t1 = 91, end_t2 = 182, end_t3 = 273, end_t4 = 365, distance = d,
coupling = 0.1)
@

where \code{phi}, \code{beta\_t1}, ..., \code{beta\_t4},
\code{end\_t1}, ..., \code{end\_t4}, and \code{distance} is local data
to each node, and passed to the transition rate functions and the
post-time step function in the \code{ldata} parameter.

The package \pkg{SimInf} has a \code{summary} method for objects of
class \code{SimInf_model}, such as the object \code{model}, which
generates a detailed summary of various data in the model and the
simulated trajectory.  Let us run a trajectory to illustrate this.

<<SISe3sp-model-summary>>=
result <- run(model = model, threads = 1, seed = 1)
summary(result)
@

Furthermore, we can display the distribution of the scheduled events
over time.  Note that the synthetic events have been generated to
illustrate features of the \pkg{SimInf} package and not to incorporate
the full complexity of population demographics and a temporal network.
The synthetic data mimics seasonality in real livestock data
\cite{Bajardi2011, Dutta2014, Widgren2016}, such that the number of
scheduled events varies over time, see
Figure~\ref{fig:scheduled-events-SISe3}.  However, the between-node
movements (\textit{external transfer}) have been generated from random
connections, which is probably not realistic for real livestock data.

\begin{figure}
  \begin{center}
<<display-SISe3sp-model, fig=TRUE>>=
plot(events(model))
@
  \end{center}
  \caption{The distribution of the synthetic scheduled events data set
    \code{events\_SISe3}, that is distributed with the \pkg{SimInf}
    package.  The \textit{enter} event adds individuals to a node.
    The \textit{internal transfer} event changes the number of
    individuals in the compartments within one node.  The
    \textit{external transfer} event moves individuals from
    compartments in one node to compartments in a destination node.
    Finally, the \textit{exit} event removes individuals from a node.}
  \label{fig:scheduled-events-SISe3}
\end{figure}

The scheduled events give rise to a seasonal variation of the
population size in each age category that can be explored from
simulated data.  The \code{trajectory} method takes a
\code{compartments} argument that can be used to determine the
population size by age category.  We use \code{as.is = TRUE} to get
the result as a matrix (the internal format in \pkg{SimInf}), instead
of as \code{data.frame}.  Let us plot the number of individuals in
each age category (Figure~\ref{fig:population}).

<<eval=FALSE>>=
N1 <- colSums(trajectory(model = result, compartments = c("S_1", "I_1"),
as.is = TRUE))
N2 <- colSums(trajectory(model = result, compartments = c("S_2", "I_2"),
as.is = TRUE))
N3 <- colSums(trajectory(model = result, compartments = c("S_3", "I_3"),
as.is = TRUE))
opar <- par(mfrow = c(3, 1), mar = c(2, 5, 1, 1))
plot(N3 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 1)
mtext("Age: 3", side = 3, line = 0)
plot(N2 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 2)
mtext("Age: 2", side = 3, line = 0)
plot(N1 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 3)
mtext("Age: 1", side = 3, line = 0)
mtext("Day", side = 1, line = 1, at = 750)
par(opar)
@

\begin{figure}
  \begin{center}
<<population-size, echo=FALSE, fig=TRUE>>=
result <- run(model = model, threads = 1, seed = 1)
N1 <- colSums(trajectory(model = result, compartments = c("S_1", "I_1"),
as.is = TRUE))
N2 <- colSums(trajectory(model = result, compartments = c("S_2", "I_2"),
as.is = TRUE))
N3 <- colSums(trajectory(model = result, compartments = c("S_3", "I_3"),
as.is = TRUE))
opar <- par(mfrow = c(3, 1), mar = c(2, 5, 1, 1))
plot(N3 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 1)
mtext("Age: 3", side = 3, line = 0)
plot(N2 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 2)
mtext("Age: 2", side = 3, line = 0)
plot(N1 ~ tspan, ylab = "N", type = "l", bty = "l", lty = 3)
mtext("Age: 1", side = 3, line = 0)
mtext("Day", side = 1, line = 1, at = 750)
par(opar)
@
  \end{center}
  \caption{The population dynamics after running one trajectory over
    $4 \times 365$ days of the \code{SISe3} model using the scheduled
    events data contained in the \pkg{SimInf} package.  Top: Plot
    showing the number of individuals older than 356 days.  Middle:
    Plot showing the number of individuals between 120 and 365 days.
    Bottom: Plot showing the number of individuals younger than 120
    days.  Please note that the y-axis do not start at zero and have
    different scales.}
  \label{fig:population}
\end{figure}

We might now be interested in exploring how various changes to the
model could influence the spread of infection in the population of
interconnected nodes.  Let us compare the spatio-temporal distribution
of disease spread when removing the effect of animal movements and
local spread.  First, we need to create a utility function to visualize
the spatio-temporal spread at evenly spaced time-points.

<<echo=false, results=hide>>=
options(continue = "+  ")
@

<<plot-infected-nodes>>=
plot_nodes <- function(x) {
  wnp <- prevalence(x, I_1+I_2+I_3~., type = "wnp", as.is = TRUE) > 0
  opar <- par(mfrow = c(3, 6), mar = c(2, 0.3, 0.3, 0.3))
  on.exit(par(opar))
  for(i in seq(1, dim(wnp)[2], length.out = 18)) {
    Si <- which(!wnp[, i])
    Ii <- which(wnp[, i])
    plot(nodes$x[Si], nodes$y[Si], col = "yellow", pch = 20, xlab = "",
      ylab = "", xaxt = "n", yaxt = "n", ann = FALSE)
    day <- 7 * as.integer(i - 1) + 1
    mtext(sprintf("Day: %i", day), side = 1, line = 0.5)
    points(nodes$x[Ii], nodes$y[Ii], col = "blue", pch = 20)
  }
}
@

<<echo=false, results=hide>>=
options(continue = "+    ")
@

To remove local spread, we have only to use the \code{gdata} function
to set the global model parameter \code{coupling} to zero and then run
the model (Figure~\ref{fig:SISe3sp-movements}).

<<eval=FALSE>>=
gdata(model, "coupling") <- 0
plot_nodes(run(model = model, threads = 1, seed = 1))
@

\begin{figure}
  \captionsetup[subfigure]{justification=centering}
  \begin{center}
    \begin{subfigure}[b]{1.0\textwidth}
      \begin{center}
<<plot-SISe3sp-I, echo=FALSE, results=hide>>=
png("SimInf-plot-SISe3sp-I.png", height = 480, width = 960)
plot_nodes(run(model = model, threads = 1, seed = 1))
dev.off()
@
        \includegraphics{SimInf-plot-SISe3sp-I.png}
        \caption{Between-node disease-spread by both movements of\\
          infected individuals and local spread among proximal nodes.}
        \label{fig:SISe3sp-movements-and-local-spred}
      \end{center}
    \end{subfigure}
    \begin{subfigure}[b]{1.0\textwidth}
      \begin{center}
<<plot-SISe3sp-II, echo=FALSE, results=hide>>=
gdata(model, "coupling") <- 0
png("SimInf-plot-SISe3sp-II.png", height = 480, width = 960)
plot_nodes(run(model = model, threads = 1, seed = 1))
dev.off()
@
        \includegraphics{SimInf-plot-SISe3sp-II.png}
        \caption{Between-node disease-spread by movements of infected
          individuals.}
        \label{fig:SISe3sp-movements}
      \end{center}
    \end{subfigure}
    \begin{subfigure}[b]{1.0\textwidth}
      \begin{center}
<<plot-SISe3sp-III, echo=FALSE, results=hide>>=
gdata(model, "coupling") <- 0.1
m <- cbind(shift_matrix(model), c(0L, -1L, 0L, -1L, 0L, -1L))
shift_matrix(model) <- m
i <- which(model@events@event == 3)
model@events@shift[i] <- ncol(m)
png("SimInf-plot-SISe3sp-III.png", height = 480, width = 960)
plot_nodes(run(model = model, threads = 1, seed = 1))
dev.off()
@
        \includegraphics{SimInf-plot-SISe3sp-III.png}
        \caption{Between-node disease-spread by local spread among
          proximal nodes.}
        \label{fig:SISe3sp-local-spread}
      \end{center}
    \end{subfigure}
    \caption{The distribution of infected nodes (among 1600 nodes
      within a 50 square kilometer region) at evenly spaced time
      points from one realization of the \code{SISe3\_sp} model over
      $4 \times 365$ days using synthetic data included in the
      \pkg{SimInf} package.}
    \label{fig:SISe3sp-spread-in-population}
  \end{center}
\end{figure}

We would also like to explore the effect on the disease-spread when
considering local spread only.  However, removing all the
\textit{external transfer} events could potentially set a node in a
state where the other event types cannot be handled due to too few
animals in the node.  Another approach to solve this is to shift all
infected animals to the susceptible state during an \textit{external
  transfer} event so that infection is not transferred, even though an
animal is moved.  This can be achieved in \pkg{SimInf} by adding one
column to the shift matrix \code{N} and use that column for the
\textit{external transfer} events (event type = 3).
Figure~\ref{fig:SISe3sp-local-spread} shows the result from running
one trajectory with the modified model.

<<eval=FALSE>>=
gdata(model, "coupling") <- 0.1
m <- cbind(shift_matrix(model), c(0L, -1L, 0L, -1L, 0L, -1L))
shift_matrix(model) <- m
i <- which(model@events@event == 3)
model@events@shift[i] <- ncol(m)
plot_nodes(run(model = model, threads = 1, seed = 1))
@

In this example, removing either local spread or animal movements was
not sufficient to eradicate the disease
(Figure~\ref{fig:SISe3sp-spread-in-population}).

%**************************************************************************

\section[Extending SimInf: New models]{Extending \pkg{SimInf}: New models}
\label{sec:extend}

One of the design goals of \pkg{SimInf} was to make it extendable.
The current design supports two ways to extend \pkg{SimInf} with new
models, and this section describes the relevant steps to implement a
new model.  Since extending \pkg{SimInf} requires that \proglang{C}
code can be compiled, you will first need to install a compiler.  To
read more about interfacing compiled code from \proglang{R} and
creating \proglang{R} add-on packages, the \texttt{'Writing R
  extensions'}
(\url{https://cran.r-project.org/doc/manuals/r-release/R-exts.html})
manual is the official guide and describes the process in detail.
Another useful resource is the \texttt{'R packages'} book by
\cite{Hadley2015} (\url{http://r-pkgs.had.co.nz/}).

\subsection{Using the model parser to define a new model}
\label{sec:mparse}

The simplest way to define a new model for \pkg{SimInf} is to use the
model parser method \code{mparse}.  It takes a character vector of
transitions in the form of \code{"X -> propensity -> Y"} and generates
the \proglang{C} and \proglang{R} code for the model.  The left hand
side of the first '\code{->}'-sign is the initial state, the right
hand side of the last '\code{->}'-sign is the final state, and the
propensity is written between the '\code{->}'-signs.  The special
symbol '\code{@}' is reserved for the empty set $\emptyset$.  We
suggest to first draw a schematic representation of the model that
includes all compartments and arrows for all state transitions.  Then
list the compartments in the order they should appear in the \code{S}
matrix.

\subsubsection[Introductory examples of using mparse]{%
  Introductory examples of using \code{mparse}}
\label{sec:mparse-introductory-examples}

In a first example we will consider the SIR model in a closed
population i.e., no births or deaths.  If we let \code{b} denote the
transmission rate and \code{g} the recovery rate, the model can be
described as,

<<SIR-mparse-I>>=
transitions <- c("S -> b*S*I/(S+I+R) -> I", "I -> g*I -> R")
compartments <- c("S", "I", "R")
@

We can now use the \code{transitions} and \code{compartments}
variables, together with the constants \code{b} and \code{g} to build
an object of class \code{'SimInf\_model'} via a call to \code{mparse}.
It also needs to be initialized with the initial condition \code{u0}
and \code{tspan}.

<<SIR-mparse-II>>=
model <- mparse(transitions = transitions, compartments = compartments,
gdata = c(b = 0.16, g = 0.077), u0 = cbind(S = 99, I = 1, R = 0),
tspan = 1:180)
@

As in earlier examples, the \code{model} object can now be used to
simulate data and plot the results.  Internally, the \proglang{C} code
that was generated by \code{mparse} is written to a temporary file
when the \code{run} method is called.  If the temporary file is
compiled successfully, the resulting DLL is dynamically loaded and
used to run one trajectory of the model.  Once the simulator
completes, the DLL is unloaded and the temporary files are removed.

<<SIR-mparse-III, eval=FALSE>>=
result <- run(model = model, threads = 1, seed = 22)
plot(result)
@

\begin{figure}
  \begin{center}
<<SIR-mparse-IV, echo=FALSE, fig=TRUE>>=
result <- run(model = model, threads = 1, seed = 22)
plot(result)
@
  \caption{Example of simulated data from one realization of the
    \code{mparse} \code{SIR} model (Equation~\ref{eq:SIR}) in one
    node, starting with 99 susceptible, 1 infected, and 0 recovered
    individuals. \label{fig:SIR-mparse-proportion}}
  \end{center}
\end{figure}

The flexibility of the \code{mparse} approach allows for quick
prototyping of new models or features.  Let us elaborate on the
previous example and explore the incidence cases per day.  This can
easily be done by adding a new compartment \code{'Icum'} whose sole
purpose is to keep track of how many individuals who become infected
over time.  The right hand side \code{'I + Icum'} of the transition
\code{'S -> b*S*I/(S+I+R) -> I + Icum'}, means that both \code{'I'}
and \code{'Icum'} are incremented by one each time the transition
happens.

<<SIR-mparse-incidence, eval=FALSE>>=
transitions <- c("S -> b*S*I/(S+I+R) -> I + Icum", "I -> g*I -> R")
compartments <- c("S", "I", "Icum", "R")
@

Since there are no between-node movements in this example, the
stochastic process in one node does not affect any other nodes in the
model.  It is therefore straightforward to run many realizations of
this model, simply by replicating a node in the initial condition
\code{u0}, for example, $n = 1000$ times.

<<SIR-mparse-incidence-run, eval=FALSE>>=
n <- 1000
u0 <- data.frame(S = rep(99, n), I = rep(1, n), Icum = rep(0, n),
R = rep(0, n))
model <- mparse(transitions = transitions, compartments = compartments,
gdata = c(b = 0.16, g = 0.077), u0 = u0, tspan = 1:150)
result <- run(model = model, threads = 1, seed = 22)
@

Let us post-process the simulated trajectory to compare the incidence
cases in the first node with the average incidence cases among all
realizations.  Extract the trajectory and calculate successive
differences of \code{'Icum'} at each time-point.

<<SIR-mparse-incidence-trajectory, eval=FALSE>>=
traj <- trajectory(model = result, compartments = "Icum")
cases <- stepfun(result@tspan[-1], diff(c(0, traj$Icum[traj$node == 1])))
avg_cases <- c(0, diff(by(traj, traj$time, function(x) sum(x$Icum))) / n)
@

Finally, plot the result as an epidemic curve
(Figure~\ref{fig:SIR-mparse-incidence}).  In this example, the number
of incident cases in the first node exceeds what is expected on
average.

<<SIR-mparse-incidence-plot, eval=FALSE>>=
plot(cases, main = "", xlab = "Time", ylab = "Number of cases",
do.points = FALSE)
lines(avg_cases, col = "blue", lwd = 2, lty = 2)
@

\begin{figure}
  \begin{center}
<<SIR-mparse-incidence-plot, echo=FALSE, fig=TRUE>>=
transitions <- c("S -> b*S*I/(S+I+R) -> I + Icum", "I -> g*I -> R")
compartments <- c("S", "I", "Icum", "R")
n <- 1000
u0 <- data.frame(S = rep(99, n), I = rep(1, n), Icum = rep(0, n),
R = rep(0, n))
model <- mparse(transitions = transitions, compartments = compartments,
gdata = c(b = 0.16, g = 0.077), u0 = u0, tspan = 1:150)
result <- run(model = model, threads = 1, seed = 22)
traj <- trajectory(model = result, compartments = "Icum")
cases <- stepfun(result@tspan[-1], diff(c(0, traj$Icum[traj$node == 1])))
avg_cases <- c(0, diff(by(traj, traj$time, function(x) sum(x$Icum))) / n)
plot(cases, main = "", xlab = "Time", ylab = "Number of cases",
do.points = FALSE)
lines(avg_cases, col = "blue", lwd = 2, lty = 2)
@
  \end{center}
  \caption{(black solid line) One realization of an epidemic curve
    displaying the number of incident cases per day in a node when
    simulating 150 days of an \code{mparse} \code{SIR} model, with
    transmission rate $\beta = 0.16$ and recovery rate $\gamma =
    0.077$ (Equation~\ref{eq:SIR}).  The simulation starts with 99
    susceptible, 1 infected and 0 recovered individuals.  (blue dashed
    line) Average number of incident cases per day from 1000
    realizations of the model.  \label{fig:SIR-mparse-incidence}}
\end{figure}

\subsubsection[Incorporate scheduled events in an mparse model]{%
  Incorporate scheduled events in an \code{mparse} model}
\label{sec:mparse-scheduled-events}

To illustrate how models generated using \code{mparse} can incorporate
scheduled events, consider an epidemic in a population consisting of
1600 nodes, for example, cattle herds, that are connected to each
other by livestock movements.  Assume an outbreak is detected on day
twenty-one after introduction of an infection in one node and that we
wish to explore how vaccination could limit the outbreak, if resources
for vaccination can handle 50 herds per day and 80\% of the animals in
each herd.  Let us add a new compartment $V$ to the model to represent
vaccinated individuals, so that the model now contains the $\{S, I,
I_{cum}, R, V \}$ compartments.  As before, let \code{b} denote the
transmission rate and \code{g} the recovery rate.

<<mparse-scheduled-events>>=
transitions <- c("S -> b*S*I/(S+I+R+V) -> I + Icum", "I -> g*I -> R")
compartments <- c("S", "I", "Icum", "R", "V")
@

Load the example data for an \code{SIR} model in a population of 1600
nodes (cattle herds) with its associated scheduled events: births,
deaths, and livestock movements.  Moreover, let $I_{cum} = 0$ and $R =
0$.

<<mparse-scheduled-events-data>>=
u0 <- u0_SIR()
u0$Icum <- 0
u0$V <- 0
events <- events_SIR()
@

Now generate vaccination events i.e., \textit{internal transfer}
events.  Use \code{select = 3} and \code{shift = 1} to move animals
from the susceptible, infectious and recovered compartments to the
vaccinated compartment, see the definitions of $E$ and $N$ below.  Let
us start the vaccinations in nodes 1--50 on day twenty-one, and
continue until all herds are vaccinated on day fifty-two.  Moreover,
use \code{proportion = 0.8} to vaccinate 80\% of the animals in each
herd.  We assume, for the sake of simplicity, that vaccinated
individuals become immune and non-infectious immediately.

<<mparse-scheduled-events-vaccination>>=
vaccination <- data.frame(event = "intTrans", time = rep(21:52, each = 50),
node = 1:1600, dest = 0, n = 0, proportion = 0.8, select = 3,
shift = 1)
@

To simulate from this model, we have to define the select matrix $E$
and the shift matrix $N$, to handle which compartments to sample from
when processing scheduled events.  Let us first define $E$, where the
first column is for \textit{enter} events (births); add newborn
animals to the susceptible compartment $S$.  The second column is for
\textit{exit} events (deaths) and \textit{external transfer} events
(livestock movements); sample animals from the $S$, $I$, $R$ or $V$
compartments.  Finally, the third column is for \textit{internal
  transfer} events (vaccination); sample individuals from the $S$, $I$
or $R$ compartments.  Then define the shift matrix $N$ to process
\textit{internal transfer} events (vaccination); move sampled animals
from the $S$ compartment four steps forward to the $V$ compartment.
Similarly, move sampled animals from the $I$ compartment three steps
forward to the $V$ compartment, and finally, move sampled individuals
from the $R$ compartment one step forward.

{\small
\[
\mathbf{E} =
\bordermatrix{
         & 1 & 2 & 3 \cr
  S      & 1 & 1 & 1 \cr
  I      & 0 & 1 & 1 \cr
  I_{cum} & 0 & 0 & 0 \cr
  R      & 0 & 1 & 1 \cr
  V      & 0 & 1 & 0} \qquad
\mathbf{N} =
\bordermatrix{
         & 1 \cr
  S      & 4 \cr
  I      & 3 \cr
  I_{cum} & 0 \cr
  R      & 1 \cr
  V      & 0}
\]
}

<<mparse-scheduled-events-E-N>>=
E <- matrix(c(1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0), nrow = 5,
ncol = 3, dimnames = list(c("S", "I", "Icum", "R", "V"),
c("1", "2", "3")))
N <- matrix(c(4, 3, 0, 1, 0), nrow = 5, ncol = 1,
dimnames = list(c("S", "I", "Icum", "R", "V"), "1"))
@

Now let us create an \code{epicurve} function to estimate the average
number of new cases per day from \code{n = 1000} realizations in a
\code{for}-loop and simulate a trajectory at a time.  To clear
infection that was introduced in the previous trajectory, animals are
first moved to the susceptible compartment.  Then, one infected
individual is introduced into a randomly sampled node from the
population.  Note that we use the 'L' suffix to create an integer
value rather than a numeric value.  Run the model and accumulate
\code{Icum}.  For efficiency, use \code{as.is = TRUE}, the internal
matrix format, to extract \code{Icum} in every node at each time-point
in \code{tspan}.

<<echo=false, results=hide>>=
options(continue = "+  ")
@

<<mparse-scheduled-events-epicurve>>=
epicurve <- function(model, n = 1000) {
  Icum <- numeric(length(model@tspan))
  for (i in seq_len(n)) {
    model@u0["S", ] <- model@u0["S", ] + model@u0["I", ]
    model@u0["I", ] <- 0L
    j <- sample(seq_len(Nn(model)), 1)
    model@u0["I", j] <- 1L
    model@u0["S", j] <- model@u0["S", j] - 1L
    result <- run(model = model)
    traj <- trajectory(model = result, compartments = "Icum",
      as.is = TRUE)
    Icum <- Icum + colSums(traj)
  }
  stepfun(model@tspan[-1], diff(c(0, Icum / n)))
}
@

<<echo=false, results=hide>>=
options(continue = "+    ")
@

Generate an epicurve with the average number of cases per day for the
first three hundred days of the epidemic without vaccination.

<<mparse-scheduled-events-model-no-vac, eval=FALSE>>=
model_no_vac <- mparse(transitions = transitions,
compartments = compartments, gdata = c(b = 0.16, g = 0.077),
u0 = u0, tspan = 1:300, events = events, E = E, N = N)
cases_no_vac <- epicurve(model_no_vac)
@

Similarly, generate an epicurve after incorporating the
\code{vaccination} events.

<<mparse-scheduled-events-model-vac, eval=FALSE>>=
model_vac <- mparse(transitions = transitions,
compartments = compartments, gdata = c(b = 0.16, g = 0.077),
u0 = u0, tspan = 1:300, events = rbind(events, vaccination),
E = E, N = N)
cases_vac <- epicurve(model_vac)
@

As expected, the number of cases decrease rapidly after vaccination,
while the outbreak is ongoing for a longer time in the unvaccinated
population (Figure~\ref{fig:mparse-epicurve}).

<<mparse-scheduled-events-plot, eval=FALSE>>=
plot(cases_no_vac, main = "", xlim = c(0, 300), xlab = "Time",
ylab = "Number of cases", do.points = FALSE)
lines(cases_vac, col = "blue", do.points = FALSE, lty = 2)
abline(v = 21, col = "red", lty = 3)
legend("topright", c("No vaccination", "Vaccination"),
col = c("black", "blue"), lty = 1:2)
@

\begin{figure}
  \begin{center}
    \includegraphics{img/mparse-epicurve.pdf}
  \end{center}
  \caption{Comparison beween the number of cases per day of an
    outbreak in an unvaccinated population of cattle herds (black
    solid line) and after vaccination of animals (blue dashed line).
    The vertical line (dotted) indicates when vaccination was
    initiated.  \label{fig:mparse-epicurve}}
\end{figure}

%**************************************************************************

\subsection[Use the SimInf framework from another package]{%
  Use the \pkg{SimInf} framework from another package}
\label{sec:linking-to}

Another possibility is to extend \pkg{SimInf} by creating an
\proglang{R} add-on package that uses \pkg{SimInf} by linking to its
core solver native routine.  To facilitate this, the \pkg{SimInf}
package includes the \code{package_skeleton} method to automate some
of the setup for a new source package.  It creates directories, saves
\proglang{R} and \proglang{C} code files to appropriate places, and
creates skeleton help files.

Although \pkg{SimInf} was designed to study disease spread over
temporal networks, it is not limited to that use case but can also be
used to study the dynamics of other systems.  Consider we wish to
create a new add-on package \pkg{PredatorPrey} based on the
Rosenzweig-MacArthur predator-prey model demonstrated in the
\pkg{GillespieSSA} package \citep{Rosenzweig1963, Pineda-Krch2008}.
The model has a density-dependent growth in the prey and and a
nonlinear Type-2 functional response in the predator
\citep{Rosenzweig1963}.  Let $R$ and $F$ denote the number of prey and
predators, respectively.  The model consists of five transitions
(Equation~\ref{eq:predator-prey}): \textit{i)} prey birth,
\textit{ii)} prey death due to non-predatory events, \textit{iii)}
prey death due to predation, \textit{iv)} predator birth, and
\textit{v)} predator death

\begin{align}
  \label{eq:predator-prey}
  \left.
     \begin{array}{rcl}
      \emptyset & \xrightarrow{b_R \cdot R} & R \\
      R & \xrightarrow{(d_R+(b_R-d_R) \cdot R/K) \cdot R} & \emptyset \\
      R & \xrightarrow{\alpha/(1+w \cdot R) \cdot R \cdot F} & \emptyset \\
      \emptyset & \xrightarrow{b_F \cdot \alpha/(1+w \cdot R) \cdot R \cdot F} & F \\
      F & \xrightarrow{d_F \cdot F} & \emptyset \\
    \end{array}
  \right\},
\end{align}

where $b_R$, $d_R$, $b_F$, and $d_F$ are the per capita birth and
death rate of the prey and predator, respectively.  Furthermore, $K$
is the carrying capacity of the prey, $\alpha$ is the predation
efficiency, and $w$ is the degree of predator saturation
\citep{Pineda-Krch2008}.  Using parameter values from
\cite{Pineda-Krch2008}, we define the model as

<<mparse-predator-prey-I>>=
transitions <- c("@ -> bR*R -> R", "R -> (dR+(bR-dR)*R/K)*R -> @",
"R -> alpha/(1+w*R)*R*F -> @", "@ -> bF*alpha/(1+w*R)*R*F -> F",
"F -> dF*F -> @")
compartments <- c("R", "F")
parameters <- c(bR = 2, bF = 2, dR = 1, K = 1000, alpha = 0.007,
w = 0.0035, dF = 2)
@

Assume the initial population, u0, consists of $R = 1000$ prey and $F
= 100$ predators and we are interested in simulating $n = 1000$
replicates over 100 days.  Since there are no between-node movements
in this example, we can generate replicates of the model simply by
starting with $n$ identical nodes.

<<mparse-predator-prey-II>>=
n <- 1000
u0 = data.frame(R = rep(1000, n), F = rep(100, n))
model <- mparse(transitions = transitions, compartments = compartments,
gdata = parameters, u0 = u0, tspan = 1:100)
@

Now instead of running the model to generate data, let us use it to
create an \proglang{R} add-on package.

<<create-package-skeleton, eval=FALSE>>=
path <- tempdir()
package_skeleton(model = model, name = "PredatorPrey", path = path)
@

Where the first argument is the model object generated by the
\code{mparse} method, the second argument is the name of the package
to create a skeleton for and the third argument is the path to the new
package. Note that a temporary directory is used here for illustration
of the functionality.  We refer to the \pkg{SimInf} documentation for
other arguments that can be supplied to the \code{package_skeleton}
method.  The created \proglang{R} file (\texttt{'R/models.R'}) defines
the \code{S4} class \code{PredatorPrey} that contains the
\code{SimInf\_model} and a generating function to create a new object
of the \code{PredatorPrey} model.  The generating function is a
template that might need to be updated to meet the specific
requirements of the model.

The \proglang{C} file (\texttt{'src/models.c'}) defines one function
for each state transition, the post time step function and the model
specific run function, and is automatically compiled when installing
the package.  The header file \code{"SimInf.h"} contains the
declarations for these functions and should be included.  The
\code{SimInf_model_run} function is the interface from \proglang{R} to
the core solver in \proglang{C} and list all function pointers to the
transition rate functions in a vector in the order the state
transitions appear in the dependency graph \code{G}, see Listings
\ref{lst:SIRrun} and \ref{lst:trSIR} in Appendix~\ref{sec:C-code-SIR}
for an example from the predefined \code{SIR} model in \pkg{SimInf}
and the use of the address of operator \code{'\&'} to obtain the
address of a function.  The \code{SimInf_model_run} function must
return the result from the call to the core solver with
\code{SimInf_run}.  The arguments to \code{SimInf_run} are the
arguments passed to the \code{SimInf_model_run} function plus the
vector of function pointers to the transition rate functions and the
function pointer to the post time step function. The add-on
\pkg{PredatorPrey} source package can now be built and installed with
the following commands.

<<install-package-skeleton, eval=FALSE>>=
pkg <- file.path(path, "PredatorPrey")
install.packages(pkg, repos = NULL, type = "source")
@

\begin{figure}
  \begin{center}
    \includegraphics{img/predator-prey.png}
  \end{center}
  \caption{Left: Phase plane trajectories from 1000 realizations of
    the Rosenzweig-MacArthur predator-prey model. Right: One
    realization of the Rosenzweig-MacArthur predator-prey model, where
    the predator go extinct after about 25 time steps while the prey
    then fluctuates around a plateu of 1000
    individuals.  \label{fig:predator-prey}}
\end{figure}

Here we let \code{repos = NULL} to install from local files and use
\code{type = "source"} to compile the files.  If the installation was
successful, the newly installed package \pkg{PredatorPrey} can be
loaded in \proglang{R} with the following command.

<<load-predator-prey, eval=FALSE>>=
library("PredatorPrey")
@

Now create a model and run it to generate data.

<<create-predator-prey-model, eval=FALSE>>=
model <- PredatorPrey(u0 = u0, tspan = 1:100, gdata = parameters)
result <- run(model, threads = 1, seed = 1)
@

Because the \code{PredatorPrey} model contains the \code{SimInf_model}
class, it can make use of utility functions provided in the
\pkg{SimInf} package, for example, \code{show}.

\begin{Schunk}
\begin{Sinput}
R> result
\end{Sinput}
\begin{Soutput}
Model: PredatorPrey
Number of nodes: 1000
Number of transitions: 5
Number of scheduled events: 0

Global model parameters
-----------------------
 Parameter Value
 bR        2.0e+00
 bF        2.0e+00
 dR        1.0e+00
 K         1.0e+03
 alpha     7.0e-03
 w         3.5e-03
 dF        2.0e+00

Discrete state variables
------------------------
   Min. 1st Qu. Median Mean 3rd Qu. Max.
 R   10     241    628  607     978 1172
 F    0       0     31  110     154  830
\end{Soutput}
\end{Schunk}

Or the \code{trajectory} method, for example, to plot the phase plane
from 1000 realizations and to extract the simulated data from the
sixth node (use \code{i = 6}) to illustrate stochastic extinction of
the predators (Figure~\ref{fig:predator-prey}).

<<predator-prey-plot, eval=FALSE>>=
opar <- par(mfrow = c(1, 2))
plot(R ~ F, trajectory(model = result), cex = 0.3, pch = 20,
xlab = "Number of predators", ylab = "Number of prey",
col = rgb(0, 0, 0, alpha = 0.1))
plot(R ~ time, trajectory(model = result, i = 6), type = "l",
xlab = "Time", ylab = "N")
lines(F ~ time, trajectory(model = result, i = 6), type = "l", lty = 2)
legend("right", c("Prey", "Predator"), lty = 1:2)
par(opar)
@

%**************************************************************************

\section{Conclusion}

In this paper we have introduced the \proglang{R} package \pkg{SimInf}
which supports data-driven simulations of disease transmission over
spatio-temporal networks. The package offers a very efficient and
highly flexible tool to incorporate real data in simulations at
realistic scales.

We hope that our package will facilitate incorporating large volumes
of available data, for example, livestock data, in network epidemic
models to better understand disease transmission in a temporal network
and improve design of intervention strategies for endemic and emerging
threats.  Future efforts will be concentrated on a software
development driven predominantly by actual use cases.

%**************************************************************************

\section{Acknowledgments}

This work was financially supported by the Swedish Research Council
within the UPMARC Linnaeus centre of Excellence (P.~Bauer,
S.~Engblom), the Swedish Research Council Formas (S.~Engblom,
S.~Widgren), the Swedish Board of Agriculture (S.~Widgren), and by the
Swedish strategic research program eSSENCE (S.~Widgren).

\clearpage

\bibliography{SimInf}

\clearpage

%**************************************************************************

\appendix

\section{Pseudo-code for the core simulation solver}
\label{sec:pseudo-code}

\begin{table*}[!ht]
  \small
  \begin{tabular}{r l}
    \toprule
    & \textbf{Algorithm} Pseudo-code for the core simulation solver
    using direct SSA \\
    \midrule

    \texttt{1:} & \textit{Run trajectory:} Dispatch to model specific
    \code{run} method. \\

    \texttt{2:} & \textit{\proglang{C} interface:} Initialize model
    transition rate functions and post time step function. \\

    \texttt{3:} & \textbf{for all} nodes $i=1$ \textbf{to} $\Nnodes$
    \textbf{do in parallel} \\

    \texttt{4:} & \quad Compute transition rates for all transitions
    $\omega_{i,j}$, $j=1, \ldots ,\Ntransitions$. \\

    \texttt{5:} & \textbf{end for} \\

    \texttt{6:} & \textbf{while} $t < T_{\text{End}}$ \textbf{do} \\

    \texttt{7:} & \quad \textbf{for all} nodes $i=1$ \textbf{to}
    $\Nnodes$ \textbf{do in parallel} \\

    \texttt{8:} & \quad \quad \textbf{loop} \\

    \texttt{9:} & \quad \quad \quad Compute sum of transition rates
    $\lambda_i = \sum_{j=1}^{\Ntransitions}\omega_{i,j}$ \\

    \texttt{10:} & \quad \quad \quad Sample time to next stochastic
    event $\tau_i = -\log(r_1)/ \lambda_i$ where $r_1$ \\ & \quad
    \quad \quad is a uniformly distributed random number in the range
    (0, 1) \\

    \texttt{11:} & \quad \quad \quad \textbf{if} $\tau_i + t_i >=
    T_{\text{Next day}}$ \textbf{then} \\

    \texttt{12:} & \quad \quad \quad \quad Move simulated time forward
    $t_i = T_{\text{Next day}}$ \\

    \texttt{13:} & \quad \quad \quad \quad go to \texttt{20} \\ % E1

    \texttt{14:} & \quad \quad \quad \textbf{end if} \\

    \texttt{15:} & \quad \quad \quad Move simulated time forward $t_i
    = t_i + \tau_i$ \\

    \texttt{16:} & \quad \quad \quad Determine which state transition
    happened; by inversion, \\ & \quad \quad \quad find $n$ such that
    $\sum_{j=1}^{n-1} \omega_{i,j} < \lambda r_2 \le \sum_{j=1}^n
    \omega_{i,j}$ where $r_2$ \\ & \quad \quad \quad is a uniformly
    distributed random number in the range (0, 1) \\

    \texttt{17:} & \quad \quad \quad Update the compartments \code{u[,
        i]} using the state-change vector \code{S[, n]} \\

    \texttt{18:} & \quad \quad \quad Use the dependency graph
    \code{G[, n]} to recalculate affected transition rates
    $\omega_{i,j}$ \\

    \texttt{19:} & \quad \quad \textbf{end loop} \\

    \texttt{20:} & \quad \quad Process $E_1$ events \\

    \texttt{21:} & \quad \textbf{end for} \\

    \texttt{22:} & \quad Process $E_2$ events \\

    \texttt{23:} & \quad \textbf{for all} nodes $i=1$ \textbf{to}
    $\Nnodes$ \textbf{do in parallel} \\

    \texttt{24:} & \quad \quad Call post time step function and update
    the continuous state variable \code{v[ ,i]}. \\

    \texttt{25:} & \quad \textbf{end for} \\

    \texttt{26:} & \quad $T_{\text{Next day}} = T_{\text{Next day}} +
    1$ \\

    \texttt{27:} & \textbf{end while} \\

    \bottomrule
  \end{tabular}
\end{table*}

\clearpage

\section{Illustration of scheduled events}
\label{sec:illustration-scheduled-events}

This section illustrates how the scheduled events for the
\code{SISe3\_sp} model are specified
(Table~\ref{table:SISe3_sp:events}) and how each event type is
executed
Figures~\ref{fig:exit},\ref{fig:enter},\ref{fig:external},\ref{fig:internal},\ref{fig:external:shift}

\begin{table}[!ht]
  \small
  \begin{tabular}{l c c c c c c c c}
    \toprule
    Action & \code{event} & \code{time} & \code{node} & \code{dest} &
    \code{n} & \code{proportion} & \code{select} & \code{shift} \\
    \midrule
    Exit individuals in $S_1$ and $I_1$  & exit     & t & i & 0 & n & 0 & 4 & 0\\
    Exit individuals in $S_2$ and $I_2$  & exit     & t & i & 0 & n & 0 & 5 & 0\\
    Exit individuals in $S_3$ and $I_3$  & exit     & t & i & 0 & n & 0 & 6 & 0\\
    Enter individuals in $S_1$ and $I_1$ & enter    & t & i & 0 & n & 0 & 1 & 0\\
    Enter individuals in $S_2$ and $I_2$ & enter    & t & i & 0 & n & 0 & 2 & 0\\
    Enter individuals in $S_3$ and $I_3$ & enter    & t & i & 0 & n & 0 & 3 & 0\\
    Age individuals in $S_1$ and $I_1$   & intTrans & t & i & 0 & n & 0 & 4 & 1\\
    Age individuals in $S_2$ and $I_2$   & intTrans & t & i & 0 & n & 0 & 5 & 2\\
    Move individuals in $S_1$ and $I_1$  & extTrans & t & i & j & n & 0 & 4 & 0\\
    Move individuals in $S_2$ and $I_2$  & extTrans & t & i & j & n & 0 & 5 & 0\\
    Move individuals in $S_3$ and $I_3$  & extTrans & t & i & j & n & 0 & 6 & 0\\
    \bottomrule
  \end{tabular}
  \caption{Examples of the specification of a single row of scheduled
    event data in the \code{SISe3\_sp} model to add, move or remove
    individuals during the simulation, where $t$ is the time-point for
    the event, $i$ is the node to operate on, $j$ is the destination
    node for a movement.}
  \label{table:SISe3_sp:events}
\end{table}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.67\linewidth]{img/exit.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{exit} event in the
    \code{SISe3\_sp} model at time = 4.  The removal of one individual
    in the third age category $\{S_3, I_3\}$ from node 14.
    Interpreting the figure from left to right: \textit{i)} A single
    row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14; \code{E[, 6]} is
    the 6$^{th}$ column in the select matrix that determines which
    compartments (age categories) that are eligible for sampling.
    \textit{iii)} The operation of randomly sampling one individual (n
    = 1) to move from the compartments selected in step \textit{ii}.
    \textit{iv)} The resultant state of node 14 after subtracting the
    sampled individual in step \textit{iii} from node 14.
    $^\dag$\code{dest} and $^\S$\code{shift} are not used in a
    scheduled \textit{exit} event.  $^\ddag$\code{proportion} is not
    used when $n > 0$.  \label{fig:exit}}
\end{figure}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.6\linewidth]{img/enter.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{enter} event in the
    \code{SISe3\_sp} model at time = 4.  Add three susceptible
    individuals to the first age category $\{S_1\}$ in node 14.
    Interpreting the figure from left to right: \textit{i)} A single
    row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14.  \textit{iii)}
    \code{E[, 1]} is the first column in the select matrix that
    determines which compartments (age categories) the new individuals
    are added.  \textit{iv)} The resultant state of node 14 after
    adding the individuals in step \textit{iii}.  $^\dag$\code{dest},
    $^\ddag$\code{proportion} and $^\S$\code{shift} are not used in a
    scheduled \textit{enter} event.  \label{fig:enter}}

  \vspace*{\floatsep}

  \begin{center}
    \includegraphics[width=0.66\linewidth]{img/external.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{external transfer}
    event in the \code{SISe3\_sp} model at time = 4.  The movement of
    one individual in the third age category $\{S_3, I_3\}$ from node
    14 to destination node 23.  Interpreting the figure from left to
    right: \textit{i)} A single row of the event data operating on
    node 14 and destination node 23.  \textit{ii)} \code{u[, 14]} is
    the current state of node 14; \code{u[, 23]} is the current state
    of the destination node 23; \code{E[, 6]} is the 6$^{th}$ column
    in the select matrix that determines which compartments (age
    categories) that are eligible for sampling.  \textit{iii)} The
    operation of randomly sampling one individual (n = 1) to move from
    the compartments selected in step \textit{ii}.  \textit{iv)} The
    resultant state of node 14 and destination node 23 after
    subtracting the sampled individuals in step \textit{iii} from node
    14 and adding them to destination node 23.  $^\dag$\code{shift}
    can be used in a scheduled \textit{external transfer} event, see
    Figure~\ref{fig:external:shift}. $^\ddag$\code{proportion} is not
    used when $n > 0$.  \label{fig:external}}
\end{figure}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=0.8\linewidth]{img/internal.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{internal transfer}
    event in the \code{SISe3\_sp} model at time = 4.  The ageing of
    three individuals in the first age category $\{S_1, I_1\}$.
    Interpreting the figure from left to right: \textit{i)} A single
    row of the event data operating on node 14.  \textit{ii)}
    \code{u[, 14]} is the current state of node 14; \code{E[, 4]} is
    the 4$^{th}$ column in the select matrix that determines which
    compartments (age categories) that are eligible for sampling.
    \textit{iii)} The operation of randomly sampling three individuals
    (n = 3) to age from the compartments selected in step \textit{ii}.
    \textit{iv)} The shift operation applies the shift specified in
    column 1 of the shift matrix (\code{N}) to the individuals sampled
    in step \textit{iii}.  \textit{v)} The resultant state of node 14
    after subtracting the sampled individuals in step \textit{iii} and
    adding the individuals after the shift operation in step
    \textit{iv}.  $^\dag$\code{dest} is not used in \textit{internal
      transfers}.  $^\ddag$\code{proportion} is not used when $n >
    0$.  \label{fig:internal}}

  \vspace*{\floatsep}

  \begin{center}
    \includegraphics[width=0.66\linewidth]{img/external-shift.pdf}
  \end{center}
  \caption{Illustration of a scheduled \textit{external transfer}
    event in the \code{SISe3} model at time = 4.  The ageing of three
    individuals in the second age category $\{S_2, I_2\}$ that are
    subsequently moved.  Interpreting the figure from left to right:
    \textit{i)} A single row of the event data operating on node 14
    and destination node 23.  \textit{ii)} \code{u[, 14]} is the
    current state of node 14; \code{u[, 23]} is the current state of
    the destination node 23; \code{E[, 5]} is the 5$^{th}$ column in
    the select matrix that determines which compartments (age
    categories) that are eligible for sampling.  \textit{iii)} The
    operation of randomly sampling three individuals (n = 3) to move
    from the compartments selected in step \textit{ii}.  \textit{iv)}
    The shift operation applies the shift specified in column 2 of the
    shift matrix (\code{N}) to the individuals sampled in step
    \textit{iii}.  \textit{v)} The resultant state of node 14 and
    destination node 23 after subtracting the sampled individuals in
    step \textit{iii} from node 14 and adding them to the destination
    node 23 after the shift operation in step \textit{iv}.
    $^\ddag$\code{proportion} is not used when $n >
    0$.  \label{fig:external:shift}}
\end{figure}

\clearpage

\section[C code for the SIR model]{\proglang{C} code for the \code{SIR} model}
\label{sec:C-code-SIR}

\begin{minipage}{\linewidth}
\begin{scriptsize}
  \begin{lstlisting}[
      language=C, caption={Implementation of the function to init and
        run a simulation with the \code{SIR} model},
      label={lst:SIRrun}, frame=single]
  SEXP SIR_run(SEXP model, SEXP threads, SEXP seed, SEXP solver)
  {
      TRFun tr_fun[] = {&SIR_S_to_I, &SIR_I_to_S};

      return SimInf_run(model, threads, seed, solver, tr_fun, &SIR_post_time_step);
  }
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{scriptsize}
\begin{lstlisting}[
    language=C, caption={Implementation of the transition rate
      functions in the \code{SIR} model for the transitions in
      Equation~\ref{eq:SIR} between the susceptible and infected
      compartments.  The enumeration declarations are used to name the
      variable offsets and facilitate extraction of the values from
      the various data vectors.}, label={lst:trSIR} , frame=single]

  /* Offset in integer compartment state vector */
  enum {S, I, R};

  /* Offsets in global data (gdata) to parameters in the model */
  enum {BETA, GAMMA};

  /* susceptible to infected: S -> I */
  double SIR_S_to_I(const int *u, const double *v, const double *ldata,
                    const double *gdata, double t)
  {
      const double S_n = u[S];
      const double I_n = u[I];
      const double n = S_n + I_n + u[R];

      if (n > 0.0)
          return (gdata[BETA] * S_n * I_n) / n;
      return 0.0;
  }

  /* infected to susceptible: I -> S */
  double SIR_I_to_S(const int *u, const double *v, const double *ldata,
                    const double *gdata, double t)
  {
      return gdata[GAMMA] * u[I];
  }
\end{lstlisting}

\begin{lstlisting}[
      language=C, caption={Implementation of the post time step
        function in the \code{SIR} model.  The post time step function
        should return a value $>0$ if the node needs to recalculate
        the transition rates for the node, a value (error code) $<0$
        if an error is detected, or otherwise $0$.  Since the post
        time step function for the \code{SIR} model does not make any
        changes to a node, it always return $0$.}, label={lst:ptsSIR}
      ,frame=single]

  int SIR_post_time_step(double *v_new, const int *u, const double *v,
                         const double *ldata, const double *gdata,
                         int node, double t)
  {
      return 0;
  }
\end{lstlisting}
\end{scriptsize}
\end{minipage}

\end{document}

%**************************************************************************
